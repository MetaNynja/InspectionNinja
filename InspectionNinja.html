<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Inspection Ninja</title>
  <style>
body {
  margin: 0;
  padding: 24px;
  background: linear-gradient(180deg, #1a1a1e 0%, #2c2c34 100%);
  color: #e5e5e7;
  font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  height: 100vh;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  position: relative;
}

#console {
  flex: 1;
  display: flex;
  flex-direction: column;
  width: 100%;
  padding: 10px 20px 20px 20px;
  background: rgba(34, 34, 40, 0.95);
  backdrop-filter: blur(12px);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
  border-radius: 16px;
  margin: 0;
  overflow: hidden;
  box-sizing: border-box;
  min-height: 0;
}

#output {
  flex: 1;
  overflow-y: auto;
  overflow-x: auto;
  padding: 16px;
  min-height: 0;
}

#output .header:first-child {
  margin-top: 0;
}

.line {
  margin: 0 0 10px 0;
  color: #e5e5e7;
}

.header {
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-weight: 500;
  font-size: 16px;
  color: #A7BEFF;
  text-align: left;
  margin: 20px 0 10px 0;
  padding-bottom: 4px;
  padding-top: 20px;
  letter-spacing: 0.02em;
}

.main-header {
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-weight: 600;
  font-size: 28px;
  color: #ffffff;
  text-align: center;
  margin: 20px 0;
  letter-spacing: 0.05em;
}

.separator {
  border-top: 1px solid #3a3a42;
  margin: 16px 0;
}

#input-line {
  background: rgba(34, 34, 40, 0.9);
  backdrop-filter: blur(12px);
  padding: 12px 20px;
  border-top: 1px solid #3a3a42;
  display: flex;
  align-items: center;
  width: 100%;
  box-sizing: border-box;
  border-radius: 0 0 16px 16px;
}

#cmd-input {
  background: rgba(44, 44, 50, 0.95);
  border: 1px solid #4a4a52;
  border-radius: 12px;
  outline: none;
  color: #e5e5e7;
  font-family: inherit;
  font-size: 14px;
  padding: 12px 16px;
  flex: 1;
  transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
}

#cmd-input:focus {
  border-color: #4160BD;
  box-shadow: 0 0 0 4px rgba(30, 144, 255, 0.3);
}

#cmd-input::placeholder {
  color: #8e8e93;
  transition: transform 0.3s ease;
}

#cmd-input:focus::placeholder {
  transform: translateX(4px);
}

a {
  color: #1e90ff;
  text-decoration: none;
  transition: all 0.2s ease;
}

a:hover {
  color: #40c4ff;
  transform: scale(1.05);
  display: inline-block;
}

.expandable {
  cursor: pointer;
  color: #1e90ff;
  text-decoration: underline;
  transition: all 0.2s ease;
}

.expandable:hover {
  color: #40c4ff;
  transform: scale(1.05);
  display: inline-block;
}

.hidden {
  display: none;
}

.blinking {
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

.expanded {
  border: 1px solid #3a3a42;
  padding: 16px;
  margin: 12px 0;
  background: rgba(44, 44, 50, 0.98);
  backdrop-filter: blur(10px);
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.expanded .line {
  margin-bottom: 14px;
}

#loadingLine {
  margin: 24px 0;
  padding: 12px;
  color: #a1a1a6;
  font-style: italic;
}

.error {
  color: #ff5555;
  font-weight: 500;
}

.custom-dropdown {
  position: relative;
  display: inline-block;
  margin-right: 16px;
}

.dropdown-toggle {
  background: rgba(44, 44, 50, 0.95);
  color: #e5e5e7;
  font-size: 14px;
  padding: 12px 16px;
  border-radius: 12px;
  cursor: pointer;
  border: 1px solid #4a4a52;
  transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
  position: relative;
  overflow: hidden;
}

.dropdown-toggle:hover {
  background: #3a3a42;
  transform: translateY(-1px);
}

.dropdown-toggle::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  background: rgba(65, 96, 189, 0.2);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  transition: width 0.3s, height 0.3s;
}

.dropdown-toggle:active::after {
  width: 200px;
  height: 200px;
}

.dropdown-menu {
  display: none;
  position: absolute;
  bottom: calc(100% + 10px);
  left: 0;
  background: rgba(44, 44, 50, 0.95);
  backdrop-filter: blur(12px);
  border: 1px solid #4a4a52;
  border-radius: 12px;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
  z-index: 4;
  width: 220px;
  transform: scale(0.95);
  transform-origin: bottom left;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.dropdown-menu.show {
  display: block;
  transform: scale(1);
}

.dropdown-option {
  padding: 12px 16px;
  color: #e5e5e7;
  cursor: pointer;
  transition: all 0.2s ease;
}

.dropdown-option:hover {
  background: #3a3a42;
  color: #1e90ff;
  transform: translateX(4px);
}

table {
  width: 100%;
  max-width: 100%;
  border-collapse: collapse;
  margin: 16px 0;
  font-size: 12px;
  border-radius: 12px;
  overflow: hidden;
  background: #222228;
  table-layout: fixed;
}

th, td {
  border: none;
  padding: 8px 12px;
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-height: 40px;
  vertical-align: middle;
  font-size: 12px;
}

table:has(#xrp-values-toggle) th:nth-child(1),
table:has(#xrp-values-toggle) td:nth-child(1) {
  width: 20%;
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
}

.xrp-values-only th:nth-child(1), .xrp-values-only td:nth-child(1) {
  width: 25%;
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
}

@media screen and (max-width: 768px) {
  th:nth-child(1), td:nth-child(1) {
    max-width: 40px;
  }
  table:has(#xrp-values-toggle) th:nth-child(1),
  table:has(#xrp-values-toggle) td:nth-child(1) {
    max-width: none;
    width: 20%;
    white-space: normal;
    overflow: visible;
    text-overflow: clip;
  }
  th:nth-child(4), td:nth-child(4),
  th:nth-child(6), td:nth-child(6),
  th:nth-child(7), td:nth-child(7) {
    min-width: 90px;
  }
}

.xrp-values-only th:nth-child(1), .xrp-values-only td:nth-child(1) { width: 25%; }
.xrp-values-only th:nth-child(4), .xrp-values-only td:nth-child(4) { width: 25%; }
.xrp-values-only th:nth-child(6), .xrp-values-only td:nth-child(6) { width: 25%; }
.xrp-values-only th:nth-child(7), .xrp-values-only td:nth-child(7) { width: 25%; }

.xrp-cell {
  display: flex;
  align-items: center;
  gap: 6px;
}

.xrp-value {
  display: inline-block;
}

.xrp-icon {
  max-height: 20px;
  width: auto;
  vertical-align: middle;
}

.details-row {
  background: rgba(44, 44, 50, 0.98);
  backdrop-filter: blur(10px);
  border-top: none;
}

.details-row td {
  padding: 16px;
  border-top: none;
  min-height: 48px;
  white-space: normal;
}

.details-content {
  padding: 12px;
  background: rgba(34, 34, 40, 0.9);
  border-radius: 8px;
}

.loading-details {
  color: #a1a1a6;
  font-style: italic;
}

.header-container {
  display: flex;
  align-items: center;
  padding: 24px 24px;
  background: rgba(34, 34, 40, 0.95);
  border-radius: 12px;
  margin-bottom: 20px;
}

.header-icon {
  width: 40px;
  height: 40px;
  margin-right: 12px;
  margin-left: 12px;
}

.header-text {
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-weight: 600;
  font-size: 20px;
  margin-left: 10px;
  color: #ffffff;
  letter-spacing: 0.03em;
}

.header-text .metanynja {
  font-family: 'Nothing You Could Do', cursive;
  font-size: 20px;
  margin-left: 10px;
  color: #1e90ff;
}

.pnl-card {
  background: 
    linear-gradient(
      45deg,
      rgba(34, 34, 40, 0.98) 25%,
      rgba(255, 255, 255, 0.05) 25%,
      rgba(255, 255, 255, 0.05) 50%,
      rgba(34, 34, 40, 0.98) 50%,
      rgba(34, 34, 40, 0.98) 75%,
      rgba(255, 255, 255, 0.05) 75%,
      rgba(255, 255, 255, 0.05) 100%
    );
  background-size: 5px 5px;
  background-color: rgba(34, 34, 40, 0.98);
  border-radius: 16px;
  padding: 24px;
  margin: 12px 0;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
  position: relative;
  color: #e5e5e7;
  font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  text-align: center;
  box-sizing: border-box;
}

.pnl-card-header {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  margin-bottom: 16px;
}

.pnl-card-icon {
  width: 32px;
  height: 32px;
  margin-right: 12px;
}

.pnl-card-title {
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-weight: 600;
  font-size: 18px;
  color: #ffffff;
}

.pnl-card-title .pnl {
  font-family: 'Nothing You Could Do', cursive;
  font-size: 17px;
  color: #FFECB3;
  margin-left: 2px;
}

.pnl-card-token {
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-weight: 600;
  font-size: 28px;
  color: #ffffff;
  margin: 12px 0 12px;
}

.pnl-card-profit {
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  font-weight: 500;
  font-size: 20px;
  margin-bottom: 20px;
}

.pnl-profit-positive {
  color: #66bb6a;
}

.pnl-profit-negative {
  color: #ef5350;
}

.pnl-card-content {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.pnl-card-row {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 80px;
}

.pnl-card-column {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.pnl-card-label {
  color: #A7BEFF;
  font-weight: 500;
  font-size: 16px;
  text-decoration: underline;
  text-decoration-thickness: 1px;
  text-underline-offset: 2px;
}

.pnl-card-value {
  color: #e5e5e7;
  font-size: 14px;
  margin-top: 8px;
}

.pnl-transactions {
  margin-top: 20px;
  padding-top: 16px;
  border-top: 1px solid #2a2a30;
  text-align: left;
}

.pnl-transactions .line {
  margin-bottom: 12px;
}

.download-btn {
  background: rgba(44, 44, 50, 0.95);
  color: #e5e5e7;
  font-size: 14px;
  padding: 10px 24px;
  border-radius: 12px;
  border: 1px solid #4a4a52;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 10px;
  transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
  margin: 16px auto 0;
}

.download-btn:hover {
  background: #3a3a42;
  transform: translateY(-1px);
}

.download-btn img {
  width: 18px;
  height: 18px;
  vertical-align: middle;
}

.download-btn:active {
  transform: translateY(0);
}

table tr.token-row.token-row-even {
  background-color: rgba(40, 40, 48, 0.98);
}

table tr.token-row.token-row-odd {
  background-color: rgba(42, 42, 50, 0.98);
}

table tr:first-child,
table tr.details-row {
  background-color: rgba(36, 36, 45, 0.98);
}

@media screen and (max-width: 768px) {
  body {
    padding: 16px;
    font-size: 12px;
  }

  .header-container {
    padding: 16px;
    margin-bottom: 12px;
  }

  .header-icon {
    width: 32px;
    height: 32px;
    margin-right: 8px;
    margin-left: 8px;
  }

  .header-text {
    font-size: 16px;
  }

  .header-text .metanynja {
    font-size: 16px;
    margin-left: 6px;
  }

  #console {
    padding: 8px 12px;
    border-radius: 12px;
  }

  #output {
    padding: 12px;
  }

  .main-header {
    font-size: 20px;
    margin: 16px 0;
  }

  .header {
    font-size: 14px;
    margin: 16px 0 8px;
    padding-top: 12px;
  }

  .line {
    margin-bottom: 8px;
  }

  .separator {
    margin: 12px 0;
  }

  .dropdown-toggle {
    max-width: 140px;
    font-size: 12px;
    padding: 8px 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .dropdown-menu {
    width: 180px;
    font-size: 12px;
    bottom: calc(100% + 8px);
  }

  .dropdown-option {
    padding: 8px 12px;
  }

  #input-line {
    padding: 8px 12px;
    z-index: 3;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: center;
  }

  .custom-dropdown {
    flex: 0 0 auto;
    max-width: 140px;
  }

  #cmd-input {
    font-size: 12px;
    padding: 8px 12px;
    flex: 1 1 auto;
    max-width: calc(100% - 156px);
    min-width: 100px;
    box-sizing: border-box;
  }

  .pnl-card-header {
    display: flex;
    align-items: center;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }

  .pnl-card-icon {
    width: 24px;
    height: 24px;
    margin-right: 8px;
  }

  .pnl-card-title {
    font-size: 14px;
    white-space: nowrap;
  }

  .pnl-card-title .pnl {
    font-size: 13px;
    margin-left: 4px;
  }

  table:has(#xrp-values-toggle) {
    font-size: 10px;
  }

  table:has(#xrp-values-toggle) th,
  table:has(#xrp-values-toggle) td {
    padding: 6px 8px;
  }

  table:has(#xrp-values-toggle) th:nth-child(1),
  table:has(#xrp-values-toggle) td:nth-child(1) {
    width: 30%;
    max-width: none;
    white-space: normal;
    overflow: visible;
    text-overflow: clip;
  }

  table:has(#xrp-values-toggle) th:nth-child(5),
  table:has(#xrp-values-toggle) td:nth-child(5),
  table:has(#xrp-values-toggle) th:nth-child(6),
  table:has(#xrp-values-toggle) td:nth-child(6) {
    display: none;
  }

  .pnl-card {
    width: 90%;
    margin: 8px auto;
    padding: 12px;
    z-index: 5;
    position: relative;
    transform: translateY(-10px);
    font-size: 12px;
  }

  .pnl-card-token {
    font-size: 20px;
    margin: 8px 0;
  }

  .pnl-card-profit {
    font-size: 16px;
    margin-bottom: 12px;
  }

  .pnl-card-row {
    gap: 40px;
  }

  .pnl-card-label {
    font-size: 14px;
  }

  .pnl-card-value {
    font-size: 12px;
    margin-top: 4px;
  }

  .pnl-transactions {
    margin-top: 12px;
    padding-top: 8px;
  }

  table {
    font-size: 10px;
    margin: 12px 0;
  }

  th, td {
    padding: 6px 8px;
    min-height: 32px;
    font-size: 10px;
  }

  .xrp-values-only th:nth-child(1),
  .xrp-values-only td:nth-child(1) {
    width: 30%;
    white-space: normal;
    overflow: visible;
    text-overflow: clip;
  }

  .xrp-values-only th:nth-child(4),
  .xrp-values-only td:nth-child(4),
  .xrp-values-only th:nth-child(7),
  .xrp-values-only td:nth-child(7) {
    width: 35%;
  }

  .details-row td {
    padding: 12px;
    min-height: 40px;
  }

  .details-content {
    padding: 8px;
  }

  .expanded {
    padding: 12px;
    margin: 8px 0;
  }

  .expanded .line {
    margin-bottom: 10px;
  }

  a, .expandable {
    font-size: 12px;
  }

  #loadingLine, .error {
    font-size: 12px;
    margin: 16px 0;
  }
}
/* New CSS for .pnl-card.downloading */
/* Updated PnL Card Download Styles */
#output .pnl-card.downloading {
  width: 1800px !important;
  height: 1600px !important;
  max-width: none !important;
  margin: 0 !important;
  transform: none !important;
  padding: 48px 96px !important;
  font-size: 28px !important;
  line-height: 1.6 !important;
  border-radius: 0 !important;
  position: absolute !important;
  z-index: 9999 !important;
  box-sizing: border-box !important;
  background: 
    linear-gradient(
      45deg,
      rgba(34, 34, 40, 0.98) 25%,
      rgba(255, 255, 255, 0.05) 25%,
      rgba(255, 255, 255, 0.05) 50%,
      rgba(34, 34, 40, 0.98) 50%,
      rgba(34, 34, 40, 0.98) 75%,
      rgba(255, 255, 255, 0.05) 75%,
      rgba(255, 255, 255, 0.05) 100%
    ) !important;
  background-size: 20px 20px !important;
  background-color: rgba(34, 34, 40, 0.98) !important;
}

#output .pnl-card.downloading .pnl-card-header {
  margin-bottom: 180px !important;
  margin-top: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: flex-start !important;
}

#output .pnl-card.downloading .pnl-card-icon {
  width: 128px !important;
  height: 128px !important;
  margin-right: 48px !important;
}

#output .pnl-card.downloading .pnl-card-title {
  font-size: 96px !important;
}

#output .pnl-card.downloading .pnl-card-title .pnl {
  font-size: 90px !important;
  margin-left: 8px !important;
}

#output .pnl-card.downloading .pnl-card-token {
  font-size: 220px !important;
  margin: 140px 0 60px 0 !important;
  word-break: keep-all !important;
  white-space: nowrap !important;
  overflow: visible !important;
  text-overflow: clip !important;
  max-width: 100% !important;
  width: 100% !important;
  text-align: center !important;
  line-height: 1 !important;
  padding: 0 5% !important;
  box-sizing: border-box !important;
}

#output .pnl-card.downloading .pnl-card-profit {
  font-size: 128px !important;
  margin-bottom: 160px !important;
}

#output .pnl-card.downloading .pnl-card-content {
  gap: 48px !important;
}

#output .pnl-card.downloading .pnl-card-row {
  gap: 360px !important;
  justify-content: center !important;
  align-items: flex-start !important;
}

#output .pnl-card.downloading .pnl-card-column {
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
}

#output .pnl-card.downloading .pnl-card-label {
  font-size: 88px !important;
  text-decoration: none !important;
}

#output .pnl-card.downloading .pnl-card-value {
  font-size: 80px !important;
  margin-top: 24px !important;
}

/* Mobile adjustments for downloading state */
@media screen and (max-width: 768px) {
  #output .pnl-card.downloading {
    width: 1800px !important;
    height: 1600px !important;
    padding: 48px 96px !important;
  }

  #output .pnl-card.downloading .pnl-card-token {
    font-size: 10vw !important;
    max-width: 90% !important;
    margin-left: auto !important;
    margin-right: auto !important;
  }

  #output .pnl-card.downloading .pnl-card-title {
    font-size: 96px !important;
  }

  #output .pnl-card.downloading .pnl-card-title .pnl {
    font-size: 90px !important;
  }
}

/* Portrait orientation adjustment */
@media (max-aspect-ratio: 1/1) {
  #output .pnl-card.downloading .pnl-card-token {
    font-size: 8vh !important;
  }
}
  </style>
  <!-- Add Google Fonts for cursive MetaNynja -->
  <link href="https://fonts.googleapis.com/css2?family=Nothing+You+Could+Do&display=swap" rel="stylesheet">
  
  
</head>
<body>
  <div class="header-container">
  <img src="https://i.ibb.co/svZT9rZQ/Magic-Eraser-250603-140451.png" alt="Inspection Ninja Icon" class="header-icon">
  <div class="header-text">Inspection Ninja</div>
</div>
  <div id="console">
  <div id="output"></div>
  <div id="input-line" class="line">
    <div class="custom-dropdown">
      <div class="dropdown-toggle" id="scope-toggle">Scope Level: Token Metrics</div>
      <div class="dropdown-menu" id="scope-menu">
        <div class="dropdown-option" data-value="overview" data-name="Token Metrics">
          Token Metrics
        </div>
        <div class="dropdown-option" data-value="dev" data-name="DEV Inspect">
          + DEV Inspect
        </div>
        <div class="dropdown-option" data-value="tier1" data-name="Tier 1 Transfers">
          + Tier 1 Transfers
        </div>
        <div class="dropdown-option" data-value="tier2" data-name="Tier 2 Transfers">
          + Tier 2 Transfers
        </div>
        <div class="dropdown-option" data-value="snipers" data-name="Snipers">
          Snipers
        </div>
        <div class="dropdown-option" data-value="wallet" data-name="Trade History">
          Trade History
        </div>
      </div>
    </div>
    <span class="prompt"></span>
    <input type="text" id="cmd-input" placeholder="Enter Issuer Address" autofocus />
  </div>
</div>

  <!-- External Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://unpkg.com/xrpl@2.6.0/build/xrpl-latest-min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script><script>
  /* ---------- Global State ---------- */
  let enrichedPayments = [];
  let lastIssuer = null;
  const purchaserDetailsCache = new Map(); // Cache for purchaser details

  /* ---------- Helper Functions ---------- */
  function hexToAscii(hex) {
    let str = '';
    for (let i = 0; i < hex.length; i += 2) {
      const charCode = parseInt(hex.substr(i, 2), 16);
      if (charCode >= 32 && charCode <= 126) {
        str += String.fromCharCode(charCode);
      }
    }
    return str;
  }

  function getCurrencyDisplay(currency) {
    return currency.length === 3 ? currency : hexToAscii(currency);
  }

  function formatAmount(amount) {
    if (amount === 'N/A' || isNaN(amount)) return amount;
    return Number(amount).toLocaleString(undefined, { maximumFractionDigits: 2 });
  }

  function updateLoadingMessage(message) {
    document.getElementById("output").innerHTML = `<div class="line" id="loadingLine">${message} <span class="blinking">...</span></div>`;
  }

  function displayError(message) {
    document.getElementById("output").innerHTML = `<div class="line error">Error: ${message}</div>`;
    addNewPrompt();
  }

  function validateIssuerAddress(address) {
    try {
      return xrpl.isValidAddress(address);
    } catch (e) {
      return false;
    }
  }

  function toggleSection(id) {
    const el = document.getElementById(id);
    if (el) {
      el.classList.toggle('hidden');
    }
  }
  function addNewPrompt() {
  const cmdInput = document.getElementById("cmd-input");
  cmdInput.value = lastIssuer || '';
  cmdInput.focus();
  window.scrollTo(0, document.body.scrollHeight);
}

  /* ---------- Data Fetching Functions ---------- */
  async function connectClient() {
    const primaryNode = 'wss://xrplcluster.com';
    const fallbackNode = 'wss://s1.ripple.com';
    const client = new xrpl.Client(primaryNode);
    try {
      await Promise.race([
        client.connect(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('XRPL client connection timed out')), 7000))
      ]);
      return client;
    } catch (error) {
      console.warn(`Failed to connect to ${primaryNode}, trying ${fallbackNode}:`, error);
      client.url = fallbackNode;
      try {
        await Promise.race([
          client.connect(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('XRPL client connection timed out')), 7000))
        ]);
        return client;
      } catch (fallbackError) {
        throw new Error(`Failed to connect to XRPL nodes: ${fallbackError.message}`);
      }
    }
  }

  async function fetchWithRetry(client, request, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
      try {
        return await Promise.race([
          client.request(request),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out')), 10000))
        ]);
      } catch (error) {
        if (i < retries - 1) {
          console.warn(`Retry ${i + 1}/${retries} for ${request.command} after error: ${error.message}`);
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          throw error;
        }
      }
    }
  }

  async function getActivatorAddress(issuer) {
    updateLoadingMessage("Fetching activator address");
    const client = await connectClient();
    try {
      const issuerTxResponse = await fetchWithRetry(client, {
        command: "account_tx",
        account: issuer,
        ledger_index_min: -1,
        ledger_index_max: -1,
        forward: true,
        limit: 1
      });

      if (!issuerTxResponse.result.transactions?.length) {
        throw new Error('No transaction history for this issuer.');
      }

      const activationTx = issuerTxResponse.result.transactions[0].tx;
      if (activationTx.TransactionType !== 'Payment' ||
          activationTx.Destination !== issuer ||
          typeof activationTx.Amount !== 'string') {
        throw new Error('Initial activation transaction is not valid.');
      }

      let activator = activationTx.Account;
      let creationDate = activationTx.date || 0;
      let isAntiSniper = false;

      const antiSniperAddress = 'rMFMJsQa1xDCcEV78ePWdpVhUoatbZmzPt';
      if (activator === antiSniperAddress) {
        isAntiSniper = true;
        updateLoadingMessage("Detected anti-sniper token, searching for true activator");

        let marker;
        let ammAddress = null;
        let txCount = 0;
        const maxTxCount = 10000;
        do {
          const paymentTxResponse = await fetchWithRetry(client, {
            command: "account_tx",
            account: issuer,
            ledger_index_min: -1,
            ledger_index_max: -1,
            forward: true,
            limit: 200,
            ...(marker ? { marker } : {})
          });

          const txs = paymentTxResponse.result.transactions || [];
          txCount += txs.length;
          console.log(`Fetched ${txs.length} transactions for issuer, total: ${txCount}`);

          for (const txObj of txs) {
            const tx = txObj.tx;
            if (tx.TransactionType === 'Payment' && tx.Account === issuer && tx.Destination !== issuer) {
              ammAddress = tx.Destination;
              console.log(`Found first Payment transaction, AMM address: ${ammAddress}`);
              break;
            }
          }
          marker = paymentTxResponse.result.marker;
          if (ammAddress || !marker || !txs.length || txCount >= maxTxCount) break;
        } while (marker);

        if (!ammAddress) {
          throw new Error(`Could not find a Payment transaction from the issuer after checking ${txCount} transactions.`);
        }

        updateLoadingMessage(`Searching AMM (${ammAddress}) for CheckCreate transaction`);
        let checkMarker;
        let trueActivator = null;
        let checkTxCount = 0;
        try {
          do {
            const ammTxResponse = await fetchWithRetry(client, {
              command: "account_tx",
              account: ammAddress,
              ledger_index_min: -1,
              ledger_index_max: -1,
              forward: true,
              limit: 200,
              ...(checkMarker ? { marker: checkMarker } : {})
            });

            const ammTxs = ammTxResponse.result.transactions || [];
            checkTxCount += ammTxs.length;
            console.log(`Fetched ${ammTxs.length} transactions for AMM, total: ${checkTxCount}`);

            for (const txObj of ammTxs) {
              const tx = txObj.tx;
              if (tx.TransactionType === 'CheckCreate') {
                trueActivator = tx.Destination;
                creationDate = tx.date || 0;
                console.log(`Found CheckCreate transaction, true activator: ${trueActivator}`);
                break;
              }
            }
            checkMarker = ammTxResponse.result.marker;
            if (trueActivator || !checkMarker || !ammTxs.length || checkTxCount >= maxTxCount) break;
          } while (checkMarker);

          if (!trueActivator) {
            throw new Error(`Could not find a CheckCreate transaction for the AMM address (${ammAddress}) after checking ${checkTxCount} transactions.`);
          }
        } catch (checkError) {
          // New logic for updated anti-sniper protocol: search issuer for first Payment with SourceTag
          console.warn(`CheckCreate not found: ${checkError.message}. Falling back to search for Payment with SourceTag on issuer account.`);
          updateLoadingMessage(`Searching issuer (${issuer}) for Payment with SourceTag`);

          let paymentMarker;
          let paymentTxCount = 0;
          do {
            const issuerPaymentTxResponse = await fetchWithRetry(client, {
              command: "account_tx",
              account: issuer,
              ledger_index_min: -1,
              ledger_index_max: -1,
              forward: true,
              limit: 200,
              ...(paymentMarker ? { marker: paymentMarker } : {})
            });

            const issuerTxs = issuerPaymentTxResponse.result.transactions || [];
            paymentTxCount += issuerTxs.length;
            console.log(`Fetched ${issuerTxs.length} transactions for issuer, total: ${paymentTxCount}`);

            for (const txObj of issuerTxs) {
              const tx = txObj.tx;
              if (tx.TransactionType === 'Payment' && typeof tx.SourceTag === 'number') {
                trueActivator = tx.Account;
                creationDate = tx.date || 0;
                console.log(`Found Payment with SourceTag, true activator: ${trueActivator}`);
                break;
              }
            }
            paymentMarker = issuerPaymentTxResponse.result.marker;
            if (trueActivator || !paymentMarker || !issuerTxs.length || paymentTxCount >= maxTxCount) break;
          } while (paymentMarker);

          if (!trueActivator) {
            throw new Error(`Could not find a Payment transaction with SourceTag for the issuer (${issuer}) after checking ${paymentTxCount} transactions.`);
          }
        }

        activator = trueActivator;
      }

      return { activator, creationDate, isAntiSniper };
    } finally {
      await client.disconnect();
    }
  }

  async function getCurrencyCode(issuer) {
    updateLoadingMessage("Fetching currency code");
    const client = await connectClient();
    try {
      const txResponse = await fetchWithRetry(client, {
        command: "account_tx",
        account: issuer,
        ledger_index_min: -1,
        ledger_index_max: -1,
        forward: false,
        limit: 200
      });
      if (txResponse.result.transactions && txResponse.result.transactions.length > 0) {
        for (const txObj of txResponse.result.transactions) {
          const tx = txObj.tx;
          if (tx.Amount && typeof tx.Amount === 'object' && tx.Amount.currency && tx.Amount.issuer === issuer) {
            return tx.Amount.currency;
          }
          if (tx.DeliveredAmount && typeof tx.DeliveredAmount === 'object' && tx.DeliveredAmount.currency && tx.DeliveredAmount.issuer === issuer) {
            return tx.DeliveredAmount.currency;
          }
        }
      }
      const gbResponse = await fetchWithRetry(client, {
        command: "gateway_balances",
        account: issuer,
        ledger_index: "validated"
      });
      if (gbResponse.result && gbResponse.result.assets) {
        const assets = gbResponse.result.assets;
        const currencies = Object.keys(assets);
        if (currencies.length > 0) {
          return currencies[0];
        }
      }
      throw new Error("Currency code not found using account_tx or gateway_balances");
    } finally {
      await client.disconnect();
    }
  }

  async function getTokenMetrics(issuer, currencyCode, activator) {
  updateLoadingMessage("Fetching token metrics");
  const client = await connectClient();
  try {
    // Fetch current balance of the activator
    const accountLinesResponse = await fetchWithRetry(client, {
      command: "account_lines",
      account: activator,
      ledger_index: "validated",
      peer: issuer
    });
    const lines = accountLinesResponse.result.lines || [];
    const tokenLine = lines.find(line => 
      line.currency === currencyCode && line.account === issuer
    );
    const currentBalance = tokenLine ? parseFloat(tokenLine.balance) : 0;

    // Fetch activator and issuer transactions
    let marker;
    const transactions = [];
    let markerIssuer;
    const issuerTxs = [];
    const seenTxs = new Set();
    let txCount = 0;
    const maxTxCount = 10000;

    do {
      const params = {
        command: "account_tx",
        account: activator,
        ledger_index_min: -1,
        ledger_index_max: -1,
        forward: true,
        limit: 200,
        ...(marker ? { marker } : {})
      };
      const txResponse = await fetchWithRetry(client, params);
      if (txResponse.result.transactions) {
        transactions.push(...txResponse.result.transactions);
        txCount += txResponse.result.transactions.length;
        console.log(`Fetched ${txResponse.result.transactions.length} activator transactions, total: ${txCount}`);
      }
      marker = txResponse.result.marker;
      if (!marker || !txResponse.result.transactions.length || txCount >= maxTxCount) break;
    } while (marker);

    txCount = 0;
    do {
      const paramsIssuer = {
        command: "account_tx",
        account: issuer,
        ledger_index_min: -1,
        ledger_index_max: -1,
        forward: true,
        limit: 200,
        ...(markerIssuer ? { marker: markerIssuer } : {})
      };
      const issuerTxResponse = await fetchWithRetry(client, paramsIssuer);
      if (issuerTxResponse.result.transactions) {
        issuerTxs.push(...issuerTxResponse.result.transactions);
        txCount += issuerTxResponse.result.transactions.length;
        console.log(`Fetched ${issuerTxResponse.result.transactions.length} issuer transactions, total: ${txCount}`);
      }
      markerIssuer = issuerTxResponse.result.marker;
      if (!markerIssuer || !issuerTxResponse.result.transactions.length || txCount >= maxTxCount) break;
    } while (markerIssuer);

    // Calculate initial balance from the first CheckCash transaction
    let initialBalance = 0;
    for (const txObj of transactions) {
      const tx = txObj.tx;
      if (
        tx.TransactionType === 'CheckCash' &&
        tx.Amount &&
        typeof tx.Amount === 'object' &&
        tx.Amount.currency === currencyCode &&
        tx.Amount.issuer === issuer
      ) {
        initialBalance = parseFloat(tx.Amount.value);
        console.log(`Found first CheckCash transaction for initial balance: ${initialBalance}`);
        break; // Stop after the first matching CheckCash
      }
    }

    // Calculate total burned tokens (sent to issuer address)
    let totalBurned = 0;
    let totalBurnedTxs = [];

    issuerTxs.forEach(txObj => {
      const tx = txObj.tx;
      const meta = txObj.meta;
      if (
        tx.TransactionType === 'Payment' &&
        tx.Destination === issuer &&
        tx.Amount &&
        typeof tx.Amount === 'object' &&
        tx.Amount.currency === currencyCode &&
        tx.Amount.issuer === issuer &&
        meta.TransactionResult === 'tesSUCCESS' &&
        !meta.AffectedNodes.some(node => node.ModifiedNode?.LedgerEntryType === 'AMM')
      ) {
        const amt = parseFloat(tx.Amount.value);
        totalBurned += amt;
        let txHash = tx.hash || txObj.tx.hash || 'N/A';
        if (!seenTxs.has(txHash)) {
          seenTxs.add(txHash);
          totalBurnedTxs.push({
            txHash,
            amount: amt,
            source: tx.Account === activator ? 'DEV' : 'OTHER'
          });
        }
      }
    });

    // Calculate sold amount
    const sold = initialBalance > 0 ? Math.max(initialBalance - (currentBalance + totalBurned), 0) : 0;

    return {
      initialBalance,
      currentBalance,
      totalBurned,
      sold,
      totalBurnedTxs
    };
  } catch (error) {
    console.error('Error in getTokenMetrics:', error);
    return { 
      initialBalance: 'N/A', 
      currentBalance: 'N/A', 
      totalBurned: 'N/A',
      sold: 'N/A', 
      totalBurnedTxs: []
    };
  } finally {
    await client.disconnect();
  }
}

  async function fetchDexscreenerData(issuer) {
    updateLoadingMessage("Fetching market data");
    try {
      const response = await Promise.race([
        axios.get(`https://api.dexscreener.com/latest/dex/search?q=${issuer}`),
        new Promise((_, reject) => setTimeout(() => reject(new Error('DexScreener request timed out')), 5000))
      ]);
      if (response.data.pairs && response.data.pairs.length > 0) {
        const pair = response.data.pairs[0];
        const fdv = pair.stats && pair.stats.fdv ? pair.stats.fdv : pair.fdv;
        const priceNative = pair.priceNative || (pair.token0 && pair.token0.priceNative ? pair.token0.priceNative : null);
        const marketCap = fdv ? `$${Number(fdv).toLocaleString()}` : 'N/A';
        const liquidity = (pair.liquidity && pair.liquidity.usd)
          ? `$${Number(pair.liquidity.usd).toLocaleString()}`
          : 'N/A';

        let supply;
        if (pair.token0) {
          if (pair.token0.supply) {
            supply = Number(pair.token0.supply);
          } else if (pair.token0.totalSupply) {
            supply = Number(pair.token0.totalSupply);
          }
        }
        if (!supply && fdv && priceNative && Number(priceNative) !== 0) {
          supply = Number(fdv) / Number(priceNative);
        }
        return { marketCap, supply, priceNative, liquidity };
      }
      return { marketCap: 'N/A', supply: 'N/A', priceNative: 'N/A', liquidity: 'N/A' };
    } catch (error) {
      console.error('Error fetching market data:', error);
      return { marketCap: 'N/A', supply: 'N/A', priceNative: 'N/A', liquidity: 'N/A' };
    }
  }

  async function getTokenInfoFromXrplTo(issuer, currency) {
    updateLoadingMessage("Fetching additional token information");
    try {
      const response = await Promise.race([
        axios.get(`https://api.xrpl.to/api/token/${issuer}_${currency}`),
        new Promise((_, reject) => setTimeout(() => reject(new Error('xrpl.to API request timed out')), 5000))
      ]);
      return response.data;
    } catch (error) {
      console.error('Error fetching additional token information:', error);
      return null;
    }
  }

  async function fetchAllTrustLines(issuer, currency) {
    updateLoadingMessage("Fetching top holders");
    const client = await connectClient();
    try {
      let trustLines = [];
      let marker;
      let txCount = 0;
      const maxTxCount = 10000;
      do {
        const response = await fetchWithRetry(client, {
          command: "account_lines",
          account: issuer,
          ledger_index: "validated",
          limit: 200,
          ...(marker ? { marker } : {})
        });
        const lines = response.result.lines.filter(line => line.currency === currency);
        trustLines = trustLines.concat(lines);
        marker = response.result.marker;
        txCount += lines.length;
        console.log(`Fetched ${lines.length} trust lines, total: ${txCount}`);
        if (!marker || !response.result.lines.length || txCount >= maxTxCount) break;
      } while (marker);

      const holders = trustLines
        .map(line => ({
          account: line.account,
          balance: Math.abs(parseFloat(line.balance))
        }))
        .filter(holder => holder.balance > 0)
        .sort((a, b) => b.balance - a.balance)
        .slice(0, 10);
      return holders;
    } catch (error) {
      console.error('Error fetching top holders:', error);
      return [];
    } finally {
      await client.disconnect();
    }
  }

  async function getPaymentTransactions(issuer, currencyCode) {
    updateLoadingMessage("Fetching payment transactions");
    const client = await connectClient();
    try {
      let payments = [];
      let marker;
      let txCount = 0;
      const maxTxCount = 10000;
      do {
        const response = await fetchWithRetry(client, {
          command: "account_tx",
          account: issuer,
          ledger_index_min: -1,
          ledger_index_max: -1,
          forward: true,
          limit: 200,
          ...(marker ? { marker } : {})
        });
        const txs = response.result.transactions || [];
        txCount += txs.length;
        console.log(`Fetched ${txs.length} payment transactions, total: ${txCount}`);
        for (const txObj of txs) {
          const tx = txObj.tx;
          const meta = txObj.meta;
          if (
            tx.TransactionType === 'Payment' &&
            meta?.DeliveredAmount &&
            typeof meta.DeliveredAmount === 'object' &&
            meta.DeliveredAmount.currency === currencyCode &&
            meta.DeliveredAmount.issuer === issuer &&
            tx.Destination !== issuer &&
            meta.TransactionResult === 'tesSUCCESS'
          ) {
            let xrpSpent = 'N/A';
            if (typeof tx.SendMax === 'string') {
              xrpSpent = parseFloat(tx.SendMax) / 1000000;
            }
            payments.push({
              txHash: tx.hash,
              purchaser: tx.Account,
              destination: tx.Destination,
              amount: parseFloat(meta.DeliveredAmount.value),
              xrpSpent: xrpSpent,
              time: tx.date,
              ledger_index: tx.ledger_index
            });
          }
          if (payments.length >= 10) break;
        }
        marker = response.result.marker;
        if (!marker || !txs.length || txCount >= maxTxCount || payments.length >= 10) break;
      } while (marker);
      return payments.sort((a, b) => a.time - b.time).slice(0, 10);
    } finally {
      await client.disconnect();
    }
  }

  async function fetchPurchaserDetails(purchaser, issuer, currencyCode) {
  const cacheKey = `${purchaser}_${issuer}_${currencyCode}`;
  if (purchaserDetailsCache.has(cacheKey)) {
    return purchaserDetailsCache.get(cacheKey);
  }

  const client = await connectClient();
  let details = {
    currentBalance: 'N/A',
    tokensSold: 0,
    xrpReceived: 0,
    tokensBought: 0,
    xrpSpent: 0,
    transfers: [],
    isDeleted: false
  };

  try {
    // Check if account exists with account_lines
    try {
      const accountLinesResponse = await fetchWithRetry(client, {
        command: "account_lines",
        account: purchaser,
        ledger_index: "validated",
        peer: issuer
      });
      const lines = accountLinesResponse.result.lines || [];
      const tokenLine = lines.find(line => 
        line.currency === currencyCode && line.account === issuer
      );
      details.currentBalance = tokenLine ? parseFloat(tokenLine.balance) : 0;
      console.log(`Current balance for ${purchaser}: ${details.currentBalance}`);
    } catch (error) {
      if (error.data?.error === 'actNotFound' || error.message.includes('account not found')) {
        console.warn(`Account ${purchaser} not found, marking as deleted.`);
        details.isDeleted = true;
        details.currentBalance = 'N/A';
        details.tokensBought = 0;
        details.xrpSpent = 0;
        details.tokensSold = 0;
        details.xrpReceived = 0;
        purchaserDetailsCache.set(cacheKey, details);
        await client.disconnect();
        return details; // Exit early for deleted accounts
      } else {
        console.error(`Error fetching account_lines for ${purchaser}:`, error);
        throw error; // Rethrow other errors
      }
    }

    // Fetch transactions for non-deleted accounts
    const forwardTxs = [];
    const reverseTxs = [];
    let forwardMarker, reverseMarker;
    let txCount = 0;
    const maxTxCount = 10000;

    try {
      do {
        console.log(`Fetching forward transactions for ${purchaser}, marker: ${JSON.stringify(forwardMarker)}`);
        const txResponse = await fetchWithRetry(client, {
          command: "account_tx",
          account: purchaser,
          ledger_index_min: -1,
          ledger_index_max: -1,
          forward: true,
          limit: 200,
          ...(forwardMarker ? { marker: forwardMarker } : {})
        });
        const txs = txResponse.result.transactions || [];
        forwardTxs.push(...txs);
        txCount += txs.length;
        console.log(`Fetched ${txs.length} forward transactions for ${purchaser}, total: ${txCount}`);
        forwardMarker = txResponse.result.marker;
        if (!forwardMarker || txCount >= maxTxCount) break;
      } while (forwardMarker);

      txCount = 0;
      do {
        console.log(`Fetching reverse transactions for ${purchaser}, marker: ${JSON.stringify(reverseMarker)}`);
        const txResponse = await fetchWithRetry(client, {
          command: "account_tx",
          account: purchaser,
          ledger_index_min: -1,
          ledger_index_max: -1,
          forward: false,
          limit: 200,
          ...(reverseMarker ? { marker: reverseMarker } : {})
        });
        const txs = txResponse.result.transactions || [];
        reverseTxs.push(...txs);
        txCount += txs.length;
        console.log(`Fetched ${txs.length} reverse transactions for ${purchaser}, total: ${txCount}`);
        reverseMarker = txResponse.result.marker;
        if (!reverseMarker || txCount >= maxTxCount) break;
      } while (reverseMarker);
    } catch (error) {
      if (error.data?.error === 'actNotFound' || error.message.includes('account not found')) {
        console.warn(`Account ${purchaser} transaction fetch failed, confirming deleted status.`);
        details.isDeleted = true;
        details.currentBalance = 'N/A';
        details.tokensBought = 0;
        details.xrpSpent = 0;
        details.tokensSold = 0;
        details.xrpReceived = 0;
        purchaserDetailsCache.set(cacheKey, details);
        await client.disconnect();
        return details;
      } else {
        console.error(`Error fetching transactions for ${purchaser}:`, error);
        throw error;
      }
    }

    const allTxs = [...new Set([...forwardTxs, ...reverseTxs].map(tx => tx.tx.hash))].map(hash => 
      forwardTxs.find(tx => tx.tx.hash === hash) || reverseTxs.find(tx => tx.tx.hash === hash)
    );
    console.log(`Total unique transactions for ${purchaser}: ${allTxs.length}`);

    for (const txEntry of allTxs) {
      const tx = txEntry.tx;
      const meta = txEntry.meta;
      if (
        (tx.TransactionType === 'Payment' || 
         tx.TransactionType === 'OfferCreate' || 
         tx.TransactionType === 'CheckCash' || 
         tx.TransactionType === 'AMMBid' || 
         tx.TransactionType === 'AMMVote') &&
        tx.Account === purchaser &&
        meta?.TransactionResult === 'tesSUCCESS'
      ) {
        console.log(`Processing tx: ${tx.hash}, Type: ${tx.TransactionType}`);

        const balanceChanges = xrpl.getBalanceChanges(meta);
        const purchaserChanges = balanceChanges.find(change => change.account === purchaser);

        if (purchaserChanges) {
          const tokenChange = purchaserChanges.balances.find(
            b => b.currency === currencyCode && b.issuer === issuer
          );
          const xrpChange = purchaserChanges.balances.find(b => b.currency === 'XRP');

          if (tokenChange && xrpChange) {
            const tokenValue = parseFloat(tokenChange.value);
            const xrpValue = parseFloat(xrpChange.value);
            console.log(`Token change: ${tokenValue}, XRP change: ${xrpValue}`);

            if (tokenValue < 0 && xrpValue > 0) {
              const tokensSold = Math.abs(tokenValue);
              const xrpReceived = xrpValue;
              details.tokensSold += tokensSold;
              details.xrpReceived += xrpReceived;
              console.log(`Sale detected: ${tx.hash}, Tokens sold: ${tokensSold}, XRP received: ${xrpReceived}`);
            } else if (tokenValue > 0 && xrpValue < 0) {
              const tokensBought = tokenValue;
              const xrpSpent = Math.abs(xrpValue);
              details.tokensBought += tokensBought;
              details.xrpSpent += xrpSpent;
              console.log(`Purchase detected: ${tx.hash}, Tokens bought: ${tokensBought}, XRP spent: ${xrpSpent}`);
            }
          }
        }

        // Check for transfers
        if (
          tx.TransactionType === 'Payment' &&
          meta?.delivered_amount &&
          typeof meta.delivered_amount === 'object' &&
          meta.delivered_amount.currency === currencyCode &&
          meta.delivered_amount.issuer === issuer &&
          tx.Destination !== purchaser &&
          tx.Destination !== issuer
        ) {
          const tokensTransferred = parseFloat(meta.delivered_amount.value);
          details.transfers.push({
            txHash: tx.hash,
            tokensTransferred,
            destination: tx.Destination
          });
          console.log(`Transfer detected: ${tx.hash}, Tokens transferred: ${tokensTransferred}, Destination: ${tx.Destination}`);
        } else if (meta) {
          const balanceChanges = xrpl.getBalanceChanges(meta);
          const recipientChanges = balanceChanges.find(
            change => change.account === tx.Destination && change.account !== issuer && change.account !== purchaser
          );
          if (recipientChanges) {
            const tokenReceived = recipientChanges.balances.find(
              b => b.currency === currencyCode && b.issuer === issuer
            );
            if (tokenReceived && parseFloat(tokenReceived.value) > 0) {
              const tokensTransferred = parseFloat(tokenReceived.value);
              details.transfers.push({
                txHash: tx.hash,
                tokensTransferred,
                destination: tx.Destination
              });
              console.log(`Transfer detected via balance changes: ${tx.hash}, Tokens transferred: ${tokensTransferred}, Destination: ${tx.Destination}`);
            }
          }
        }
      }
    }

    console.log(`Final details for ${purchaser}:`, details);
    purchaserDetailsCache.set(cacheKey, details);
    return details;
  } catch (error) {
    console.error(`Error fetching purchaser details for ${purchaser}:`, error);
    if (error.data?.error === 'actNotFound' || error.message.includes('account not found')) {
      details.isDeleted = true;
      details.currentBalance = 'N/A';
      details.tokensBought = 0;
      details.xrpSpent = 0;
      details.tokensSold = 0;
      details.xrpReceived = 0;
      purchaserDetailsCache.set(cacheKey, details);
    } else {
      throw error; // Rethrow unexpected errors
    }
    return details;
  } finally {
    await client.disconnect();
  }
}

  async function fetchTradeData(devWallet, issuer, currencyCode, creationDate) {
    updateLoadingMessage("Fetching developer trade data");
    const client = await connectClient();
    try {
      let allDevTxs = [];
      let marker;
      let txCount = 0;
      const maxTxCount = 10000;
      do {
        const req = {
          command: "account_tx",
          account: devWallet,
          ledger_index_min: -1,
          ledger_index_max: -1,
          forward: true,
          limit: 200,
          ...(marker ? { marker } : {})
        };
        const devTxResponse = await fetchWithRetry(client, req);
        const txs = devTxResponse.result.transactions || [];
        allDevTxs = allDevTxs.concat(txs);
        txCount += txs.length;
        console.log(`Fetched ${txs.length} DEV transactions, total: ${txCount}`);
        marker = devTxResponse.result.marker;
        if (!marker || !txs.length || txCount >= maxTxCount) break;
      } while (marker);

      let sales = [];
      let purchases = [];
      let transfers = [];
      for (const txEntry of allDevTxs) {
        const tx = txEntry.tx;
        const meta = txEntry.meta;
        if (tx.date && tx.date < creationDate) continue;
        if (tx.TransactionType !== 'Payment' || !meta || meta.TransactionResult !== 'tesSUCCESS') continue;

        const balanceChanges = xrpl.getBalanceChanges(meta);
        const devChanges = balanceChanges.find(change => change.account === devWallet);
        if (!devChanges) continue;

        const tokenChange = devChanges.balances.find(
          b => b.currency === currencyCode && b.issuer === issuer
        );
        const xrpChange = devChanges.balances.find(b => b.currency === 'XRP');

        if (tokenChange && xrpChange) {
          if (parseFloat(tokenChange.value) < 0 && parseFloat(xrpChange.value) > 0) {
            const tokensSold = -parseFloat(tokenChange.value);
            const xrpReceived = parseFloat(xrpChange.value);
            sales.push({ txHash: tx.hash, tokensSold, xrpReceived });
            console.log(`DEV sale detected: ${tx.hash}, Tokens sold: ${tokensSold}, XRP received: ${xrpReceived}`);
          } else if (parseFloat(tokenChange.value) > 0 && parseFloat(xrpChange.value) < 0) {
            const tokensBought = parseFloat(tokenChange.value);
            const xrpSpent = -parseFloat(xrpChange.value);
            purchases.push({ txHash: tx.hash, tokensBought, xrpSpent });
            console.log(`DEV purchase detected: ${tx.hash}, Tokens bought: ${tokensBought}, XRP spent: ${xrpSpent}`);
          }
        }

        if (meta.delivered_amount && typeof meta.delivered_amount === 'object' &&
            meta.delivered_amount.currency === currencyCode &&
            meta.delivered_amount.issuer === issuer &&
            tx.Destination !== devWallet &&
            tx.Destination !== issuer) {
          const tokensTransferred = parseFloat(meta.delivered_amount.value);
          transfers.push({ txHash: tx.hash, tokensTransferred, destination: tx.Destination });
          console.log(`DEV transfer detected: ${tx.hash}, Tokens transferred: ${tokensTransferred}, Destination: ${tx.Destination}`);
        } else {
          const recipientChanges = balanceChanges.find(change => change.account === tx.Destination && change.account !== issuer && change.account !== devWallet);
          if (recipientChanges) {
            const tokenReceived = recipientChanges.balances.find(
              b => b.currency === currencyCode && b.issuer === issuer
            );
            if (tokenReceived && parseFloat(tokenReceived.value) > 0) {
              const tokensTransferred = parseFloat(tokenReceived.value);
              transfers.push({ txHash: tx.hash, tokensTransferred, destination: tx.Destination });
              console.log(`DEV transfer detected via balance changes: ${tx.hash}, Tokens transferred: ${tokensTransferred}, Destination: ${tx.Destination}`);
            }
          }
        }
      }
      const totalTokensSold = sales.reduce((sum, s) => sum + s.tokensSold, 0);
      const totalTokensBought = purchases.reduce((sum, p) => sum + p.tokensBought, 0);
      const totalTokensTransferred = transfers.reduce((sum, t) => sum + t.tokensTransferred, 0);
      const totalXrpReceived = sales.reduce((sum, s) => sum + s.xrpReceived, 0);
      const totalXrpSpent = purchases.reduce((sum, p) => sum + p.xrpSpent, 0);
      const uniqueTransferAddresses = new Set(transfers.map(t => t.destination)).size;
      return { 
        sales, 
        purchases, 
        transfers, 
        totalTokensSold, 
        totalTokensBought, 
        totalTokensTransferred, 
        totalXrpReceived, 
        totalXrpSpent, 
        uniqueTransferAddresses 
      };
    } catch (error) {
      console.error('Error fetching trade data:', error);
      return { 
        sales: [], 
        purchases: [], 
        transfers: [], 
        totalTokensSold: 0, 
        totalTokensBought: 0, 
        totalTokensTransferred: 0,
        totalXrpReceived: 0,
        totalXrpSpent: 0,
        uniqueTransferAddresses: 0
      };
    } finally {
      await client.disconnect();
    }
  }

  async function fetchWalletTransactions(wallet, currencyCode, issuer, creationDate) {
    updateLoadingMessage(`Fetching wallet transactions for ${wallet}`);
    const client = await connectClient();
    try {
      let allTxs = [];
      let marker;
      let txCount = 0;
      const maxTxCount = 10000;
      do {
        const req = {
          command: "account_tx",
          account: wallet,
          ledger_index_min: -1,
          ledger_index_max: -1,
          forward: true,
          limit: 200,
          ...(marker ? { marker } : {})
        };
        const resp = await fetchWithRetry(client, req);
        const txs = resp.result.transactions || [];
        allTxs = allTxs.concat(txs);
        txCount += txs.length;
        console.log(`Fetched ${txs.length} transactions for ${wallet}, total: ${txCount}`);
        marker = resp.result.marker;
        if (!marker || !txs.length || txCount >= maxTxCount) break;
      } while (marker);
      
      let transfers = [];
      for (const txEntry of allTxs) {
        const tx = txEntry.tx;
        const meta = txEntry.meta;
        if (tx.date && tx.date < creationDate) continue;
        if (tx.TransactionType !== 'Payment' || !meta || meta.TransactionResult !== 'tesSUCCESS') continue;

        if (meta.delivered_amount && typeof meta.delivered_amount === 'object' &&
            meta.delivered_amount.currency === currencyCode &&
            meta.delivered_amount.issuer === issuer &&
            tx.Destination !== wallet && 
            tx.Destination !== issuer) {
          const tokensTransferred = parseFloat(meta.delivered_amount.value);
          transfers.push({ txHash: tx.hash, tokensTransferred, destination: tx.Destination });
          console.log(`Transfer detected: ${tx.hash}, Tokens transferred: ${tokensTransferred}, Destination: ${tx.Destination}`);
        } else {
          const balanceChanges = xrpl.getBalanceChanges(meta);
          const recipientChanges = balanceChanges.find(change => change.account === tx.Destination && change.account !== issuer && change.account !== wallet);
          if (recipientChanges) {
            const tokenReceived = recipientChanges.balances.find(
              b => b.currency === currencyCode && b.issuer === issuer
            );
            if (tokenReceived && parseFloat(tokenReceived.value) > 0) {
              const tokensTransferred = parseFloat(tokenReceived.value);
              transfers.push({ txHash: tx.hash, tokensTransferred, destination: tx.Destination });
              console.log(`Transfer detected via balance changes: ${tx.hash}, Tokens transferred: ${tokensTransferred}, Destination: ${tx.Destination}`);
            }
          }
        }
      }
      return { transfers };
    } catch (error) {
      console.error(`Error fetching transactions for ${wallet}:`, error);
      return { transfers: [] };
    } finally {
      await client.disconnect();
    }
  }

  async function fetchTradeActivity(address, currencyCode, issuer, creationDate) {
  updateLoadingMessage(`Fetching trade activity for address ${address}`);
  const client = await connectClient();
  let totalTokensSold = 0;
  let totalXrpReceived = 0;
  let totalTokensBought = 0;
  let totalXrpSpent = 0;
  let saleTxs = [];
  let purchaseTxs = [];
  try {
    let marker;
    let txCount = 0;
    const maxTxCount = 10000;
    do {
      const req = {
        command: "account_tx",
        account: address,
        ledger_index_min: -1,
        ledger_index_max: -1,
        forward: true,
        limit: 200,
        ...(marker ? { marker } : {})
      };
      const response = await fetchWithRetry(client, req);
      const txs = response.result.transactions || [];
      txCount += txs.length;
      console.log(`Fetched ${txs.length} trade activity transactions for ${address}, total: ${txCount}`);

      for (const txEntry of txs) {
        const tx = txEntry.tx;
        if (tx.date && tx.date < creationDate) continue;
        if (!txEntry.meta || txEntry.meta.TransactionResult !== 'tesSUCCESS') continue;
        if (tx.TransactionType === 'CheckCash') {
          console.log(`Skipped CheckCash transaction for ${address}: ${tx.hash}`);
          continue; // Skip CheckCash transactions
        }

        const balanceChanges = xrpl.getBalanceChanges(txEntry.meta);
        const addressChanges = balanceChanges.find(change => change.account === address);
        if (addressChanges) {
          const tokenChange = addressChanges.balances.find(
            b => b.currency === currencyCode && b.issuer === issuer
          );
          const xrpChange = addressChanges.balances.find(b => b.currency === 'XRP');
          
          if (tokenChange && xrpChange) {
            const tokenValue = parseFloat(tokenChange.value);
            const xrpValue = parseFloat(xrpChange.value);
            if (tokenValue < 0 && xrpValue > 0) {
              const tokensSold = Math.abs(tokenValue);
              const xrpReceived = xrpValue;
              totalTokensSold += tokensSold;
              totalXrpReceived += xrpReceived;
              saleTxs.push({ txHash: tx.hash, tokensSold, xrpReceived });
              console.log(`Sale detected for ${address}: ${tx.hash}, Tokens sold: ${tokensSold}, XRP received: ${xrpReceived}`);
            } else if (tokenValue > 0 && xrpValue < 0) {
              const tokensBought = tokenValue;
              const xrpSpent = Math.abs(xrpValue);
              totalTokensBought += tokensBought;
              totalXrpSpent += xrpSpent;
              purchaseTxs.push({ txHash: tx.hash, tokensBought, xrpSpent });
              console.log(`Purchase detected for ${address}: ${tx.hash}, Tokens bought: ${tokensBought}, XRP spent: ${xrpSpent}`);
            }
          } else {
            console.log(`No relevant token/XRP balance changes for ${address} in tx: ${tx.hash}`);
          }
        } else {
          console.log(`No balance changes for ${address} in tx: ${tx.hash}`);
        }
      }
      marker = response.result.marker;
      if (!marker || !txs.length || txCount >= maxTxCount) break;
    } while (marker);
  } catch (e) {
    console.error(`Error fetching trade activity for ${address}:`, e);
  } finally {
    await client.disconnect();
  }
  console.log(`Trade activity for ${address}:`, { totalTokensSold, totalXrpReceived, totalTokensBought, totalXrpSpent, saleTxs, purchaseTxs });
  return { totalTokensSold, totalXrpReceived, totalTokensBought, totalXrpSpent, saleTxs, purchaseTxs };
}
  
  function buildTableHTML(arr, type, tokenName) {
  if (!Array.isArray(arr) || arr.length === 0) {
    console.log(`buildTableHTML: No ${type} transactions provided`, { arr, type, tokenName });
    return `<div class="line">No ${type} transactions found.</div>`;
  }
  let html = `<div class="expanded">`;
  try {
    if (type === 'transfer') {
      for (const item of arr) {
        if (!item.txHash || !item.tokensTransferred || !item.destination) {
          console.warn(`Invalid transfer item in buildTableHTML:`, item);
          continue;
        }
        html += `<div class="line"><a href="https://xrpscan.com/tx/${item.txHash}" target="_blank">view</a> | ${formatAmount(item.tokensTransferred)} ${tokenName} was transferred to <a href="https://xrpscan.com/account/${item.destination}" target="_blank">${item.destination}</a></div>`;
      }
    } else if (type === 'burned') {
      for (const item of arr) {
        if (!item.txHash || !item.amount) {
          console.warn(`Invalid burned item in buildTableHTML:`, item);
          continue;
        }
        html += `<div class="line"><a href="https://xrpscan.com/tx/${item.txHash}" target="_blank">view</a> | ${formatAmount(item.amount)} ${tokenName}${item.source === 'DEV' ? ' (DEV)' : ''}</div>`;
      }
    } else if (type === 'sale') {
      for (const item of arr) {
        if (!item.txHash || !item.tokensSold || !item.xrpReceived) {
          console.warn(`Invalid sale item in buildTableHTML:`, item);
          continue;
        }
        html += `<div class="line"><a href="https://xrpscan.com/tx/${item.txHash}" target="_blank">view</a> | ${formatAmount(item.tokensSold)} ${tokenName} was sold for ${formatAmount(item.xrpReceived)} XRP</div>`;
      }
    } else if (type === 'purchase') {
      for (const item of arr) {
        if (!item.txHash || !item.tokensBought || !item.xrpSpent) {
          console.warn(`Invalid purchase item in buildTableHTML:`, item);
          continue;
        }
        html += `<div class="line"><a href="https://xrpscan.com/tx/${item.txHash}" target="_blank">view</a> | ${formatAmount(item.tokensBought)} ${tokenName} was bought for ${formatAmount(item.xrpSpent)} XRP</div>`;
      }
    } else {
      console.warn(`Unknown transaction type in buildTableHTML: ${type}`);
      html += `<div class="line">Unknown transaction type: ${type}</div>`;
    }
    if (html === `<div class="expanded">`) {
      console.log(`buildTableHTML: No valid ${type} transactions after filtering`, { arr });
      html += `<div class="line">No valid ${type} transactions found.</div>`;
    }
  } catch (e) {
    console.error(`Error in buildTableHTML for type ${type}:`, e, { arr, tokenName });
    html += `<div class="line">Error rendering ${type} transactions.</div>`;
  }
  html += `</div>`;
  return html;
}

  async function togglePurchaserDetails(txHash, purchaser, issuer, currencyCode) {
  const detailsRow = document.getElementById(`details_${txHash}`);
  if (!detailsRow.classList.contains('hidden')) {
    detailsRow.classList.add('hidden');
    return;
  }

  const detailsContent = document.getElementById(`details_content_${txHash}`);
  if (!detailsContent.innerHTML) {
    detailsContent.innerHTML = `
      <div class="details-content">
        <div class="line loading-details">Loading purchaser details <span class="blinking">...</span></div>
      </div>
    `;
    detailsRow.classList.remove('hidden');

    try {
      const details = await fetchPurchaserDetails(purchaser, issuer, currencyCode);
      let detailsHTML = '';

      if (details.isDeleted) {
        detailsHTML += `
          <div class="line error">Purchaser wallet appears to be deleted. Transaction history may still be available on <a href="https://xrpscan.com/account/${purchaser}" target="_blank">XRPSCAN</a>.</div>
        `;
      } else {
        const profit = details.xrpReceived - details.xrpSpent;
        const profitLabel = profit >= 0 ? 'Profit' : 'Loss';
        detailsHTML += `
          <div class="line">Current Balance: ${formatAmount(details.currentBalance)} ${getCurrencyDisplay(currencyCode)}</div>
          <div class="line">Tokens Purchased: ${formatAmount(details.tokensBought)} ${getCurrencyDisplay(currencyCode)}</div>
          <div class="line">XRP Spent on Purchases: ${formatAmount(details.xrpSpent)} XRP</div>
          <div class="line">Tokens Sold: ${formatAmount(details.tokensSold)} ${getCurrencyDisplay(currencyCode)}</div>
          <div class="line">XRP Received from Sales: ${formatAmount(details.xrpReceived)} XRP</div>
          <div class="line">${profitLabel}: ${formatAmount(Math.abs(profit))} XRP</div>
        `;
        if (details.transfers.length > 0) {
          detailsHTML += `
            <div class="line">Transfers: ${formatAmount(details.transfers.reduce((sum, t) => sum + t.tokensTransferred, 0))} ${getCurrencyDisplay(currencyCode)} to ${new Set(details.transfers.map(t => t.destination)).size} unique addresses <span class="expandable" onclick="toggleSection('transfers_${txHash}_${purchaser}')">[view transfers]</span></div>
            <div id="transfers_${txHash}_${purchaser}" class="hidden">${buildTableHTML(details.transfers, 'transfer', getCurrencyDisplay(currencyCode))}</div>
          `;
        } else {
          detailsHTML += `<div class="line">Transfers: None</div>`;
        }
      }

      detailsContent.innerHTML = `
        <div class="details-content">
          ${detailsHTML}
        </div>
      `;
    } catch (error) {
      console.error(`Error in togglePurchaserDetails for ${purchaser}:`, error);
      detailsContent.innerHTML = `
        <div class="details-content">
          <div class="line error">Error loading purchaser details: ${error.message}. View transaction history on <a href="https://xrpscan.com/account/${purchaser}" target="_blank">XRPSCAN</a>.</div>
        </div>
      `;
    }
  } else {
    detailsRow.classList.remove('hidden');
  }
}

  function toggleXrpValuesOnly() {
  const isXrpOnly = document.getElementById('xrp-values-toggle').checked;
  const table = document.querySelector('#output table');
  if (!table) return;

  // Select columns for Balance (2), Bought (3), Sold (5)
  const columnsToToggle = [2, 3, 5];
  const rows = table.querySelectorAll('tr');

  // Toggle xrp-values-only class on table
  if (isXrpOnly) {
    table.classList.add('xrp-values-only');
  } else {
    table.classList.remove('xrp-values-only');
  }

  rows.forEach(row => {
    const cells = row.querySelectorAll('th, td');
    columnsToToggle.forEach(colIndex => {
      if (cells[colIndex - 1]) {
        cells[colIndex - 1].style.display = isXrpOnly ? 'none' : '';
      }
    });
  });
}
  function toggleZeroBalanceOnly() {
  const isZeroBalanceOnly = document.getElementById('zero-balance-toggle').checked;
  const table = document.querySelector('#output table');
  if (!table) return;

  const rows = table.querySelectorAll('tr');
  rows.forEach((row, index) => {
    // Skip header row and details rows
    if (index === 0 || row.classList.contains('details-row')) return;
    const balanceCell = row.querySelector('td:nth-child(2)');
    if (!balanceCell) return;
    const balance = parseFloat(balanceCell.textContent.replace(/,/g, '')) || 0;
    row.style.display = isZeroBalanceOnly && balance !== 0 ? 'none' : '';
  });
}
  
  function downloadPnLCard(cardId, tokenName) {
  const cardElement = document.getElementById(cardId);
  if (!cardElement) {
    console.error(`PnL card with ID ${cardId} not found`);
    alert('PnL card not found. Please try again.');
    return;
  }

  // Backup original styles
  const originalStyles = {
    width: cardElement.style.width,
    height: cardElement.style.height,
    position: cardElement.style.position,
    zIndex: cardElement.style.zIndex,
    transform: cardElement.style.transform,
    overflow: cardElement.style.overflow
  };

  // Temporarily show hidden content (except transactions/download button)
  const hiddenElements = cardElement.querySelectorAll('.hidden:not(.pnl-transactions .hidden)');
  const transactionsSection = cardElement.querySelector('.pnl-transactions');
  const downloadButton = cardElement.querySelector('.download-btn');
  
  hiddenElements.forEach(el => el.classList.remove('hidden'));
  if (transactionsSection) transactionsSection.style.display = 'none';
  if (downloadButton) downloadButton.style.display = 'none';

  // Apply download-optimized styles
  cardElement.style.width = '1800px';
  cardElement.style.height = '1600px';
  cardElement.style.position = 'absolute';
  cardElement.style.zIndex = '9999';
  cardElement.style.overflow = 'visible';
  cardElement.classList.add('downloading');

  // Measure text width and adjust font size if needed
  const tokenElement = cardElement.querySelector('.pnl-card-token');
  const tempSpan = document.createElement('span');
  tempSpan.style.visibility = 'hidden';
  tempSpan.style.whiteSpace = 'nowrap';
  tempSpan.style.font = window.getComputedStyle(tokenElement).font;
  tempSpan.textContent = tokenName;
  document.body.appendChild(tempSpan);
  
  const maxWidth = tokenElement.clientWidth * 0.9; // 90% of container
  const textWidth = tempSpan.clientWidth;
  document.body.removeChild(tempSpan);

  if (textWidth > maxWidth) {
    const scaleFactor = maxWidth / textWidth;
    tokenElement.style.fontSize = `${220 * scaleFactor}px`; // Scale down from 220px
  }

  // Capture after a brief delay
  setTimeout(() => {
    html2canvas(cardElement, {
      backgroundColor: null,
      width: 1800,
      height: 1600,
      scale: 2,
      useCORS: true,
      logging: true
    }).then(canvas => {
      // Restore original state
      cardElement.classList.remove('downloading');
      Object.assign(cardElement.style, originalStyles);
      hiddenElements.forEach(el => el.classList.add('hidden'));
      if (transactionsSection) transactionsSection.style.display = '';
      if (downloadButton) downloadButton.style.display = '';
      tokenElement.style.fontSize = ''; // Reset dynamic scaling

      // Trigger download
      const link = document.createElement('a');
      link.download = `PnL_${tokenName.replace(/[^\w]/g, '_')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }).catch(error => {
      console.error('Download failed:', error);
      // Emergency restore
      cardElement.classList.remove('downloading');
      Object.assign(cardElement.style, originalStyles);
      hiddenElements.forEach(el => el.classList.add('hidden'));
      if (transactionsSection) transactionsSection.style.display = '';
      if (downloadButton) downloadButton.style.display = '';
      alert('Download failed. Check console for details.');
    });
  }, 200); // Slightly longer delay for rendering stability
}
  /* ---------- Scope Modules ---------- */
  const scopeModules = {
    overview: {
      async fetchData(issuer, currencyCode, activatorData, commonData) {
        const { activator, creationDate, isAntiSniper } = activatorData;
        const metrics = await getTokenMetrics(issuer, currencyCode, activator);
        const marketData = await fetchDexscreenerData(issuer);
        const xrplToData = await getTokenInfoFromXrplTo(issuer, currencyCode);
        const topHolders = await fetchAllTrustLines(issuer, currencyCode);

        let supply;
        if (xrplToData) {
          if (xrplToData.supply != null) {
            supply = Number(xrplToData.supply);
          } else if (xrplToData.token && xrplToData.token.supply != null) {
            supply = Number(xrplToData.token.supply);
          }
        }
        if (supply == null) { supply = marketData.supply; }
        const token = {
          issuer,
          currency: currencyCode,
          supply: (supply !== 'N/A') ? supply : 'N/A',
          marketCap: marketData.marketCap,
          liquidity: marketData.liquidity
        };

        if (isAntiSniper) {
          token.classification = "Anti-Sniper Token";
        }

        return { token, metrics, marketData, topHolders, creationDate };
      },
      renderData(data) {
        const { token, metrics, marketData, topHolders } = data;
        let currentTokenSupply = token.supply;
        let currentDevPercentage = 'N/A';
        if (
          currentTokenSupply !== 'N/A' && 
          !isNaN(currentTokenSupply) && 
          metrics.currentBalance !== 'N/A' && 
          !isNaN(metrics.currentBalance) && 
          Number(currentTokenSupply) > 0
        ) {
          currentDevPercentage = ((metrics.currentBalance / Number(currentTokenSupply)) * 100).toFixed(2) + '%';
        }

        let html = `<div class="header">Token Overview</div>`;
        html += `<div class="separator"></div>`;
        html += `<div class="line">Currency: ${getCurrencyDisplay(token.currency)}</div>`;
        if (token.classification) {
          html += `<div class="line">Classification: ${token.classification}</div>`;
        }
        html += `<div class="line">Market Cap: ${token.marketCap} | Liquidity: ${token.liquidity}</div>`;
        html += `<div class="line">Current Token Supply: ${(currentTokenSupply !== 'N/A') ? formatAmount(currentTokenSupply) : currentTokenSupply}</div>`;
        html += `<div class="line">Total Supply Burned: ${(metrics.totalBurned !== 'N/A') ? formatAmount(metrics.totalBurned) : metrics.totalBurned} <span class="expandable" onclick="toggleSection('burned_${token.issuer}')">[expand]</span></div>`;
        html += `<div id="burned_${token.issuer}" class="hidden">${buildTableHTML(metrics.totalBurnedTxs, 'burned', getCurrencyDisplay(token.currency))}</div>`;
        
        html += `<div class="line">Top 10 Holders: <span class="expandable" onclick="toggleSection('topHolders_${token.issuer}')">[expand]</span></div>`;
        html += `<div id="topHolders_${token.issuer}" class="hidden">`;
        if (topHolders.length > 0) {
          const totalSupply = Number(currentTokenSupply);
          topHolders.forEach((holder, index) => {
            const percentage = !isNaN(totalSupply) && totalSupply > 0 ? 
              (holder.balance / totalSupply * 100).toFixed(2) + '%' : 'N/A';
            const xrpEquivalent = marketData.priceNative !== 'N/A' && !isNaN(marketData.priceNative) ? 
              (holder.balance * Number(marketData.priceNative)).toFixed(2) : 'N/A';
            const isDev = holder.account === data.activator ? ' (DEV)' : '';
            html += `<div class="line">${index + 1}. <a href="https://xrpscan.com/account/${holder.account}" target="_blank">${holder.account}</a>${isDev}: ${formatAmount(holder.balance)} (${percentage}) - ${xrpEquivalent} XRP</div>`;
          });
        } else {
          html += `<div class="line">No holder data available.</div>`;
        }
        html += `</div>`;
        return html;
      }
    },
    dev: {
      async fetchData(issuer, currencyCode, activatorData, commonData) {
        const { activator, creationDate } = activatorData;
        const tradeData = await fetchTradeData(activator, issuer, currencyCode, creationDate);
        return { tradeData, activator, creationDate, ...commonData };
      },
      renderData(data) {
        const { tradeData, activator, token, metrics } = data;
        let currentTokenSupply = token.supply;
        let currentDevPercentage = 'N/A';
        if (
          currentTokenSupply !== 'N/A' && 
          !isNaN(currentTokenSupply) && 
          metrics.currentBalance !== 'N/A' && 
          !isNaN(metrics.currentBalance) && 
          Number(currentTokenSupply) > 0
        ) {
          currentDevPercentage = ((metrics.currentBalance / Number(currentTokenSupply)) * 100).toFixed(2) + '%';
        }

        let html = `<div class="header">Developer Inspection</div>`;
        html += `<div class="separator"></div>`;
        html += `<div class="line">Dev Wallet: <a href="https://xrpscan.com/account/${activator}" target="_blank">${activator}</a></div>`;
        html += `<div class="line">Initial Dev Supply: ${formatAmount(metrics.initialBalance)}</div>`;
        html += `<div class="line">Current Balance: ${(metrics.currentBalance !== 'N/A') ? formatAmount(metrics.currentBalance) : metrics.currentBalance} (${currentDevPercentage})</div>`;
        html += `<div class="line">Sold: ${formatAmount(tradeData.totalTokensSold)} (XRP Received: ${formatAmount(tradeData.totalXrpReceived)}) <span class="expandable" onclick="toggleSection('sales_${token.issuer}')">[expand]</span></div>`;
        html += `<div id="sales_${token.issuer}" class="hidden">${buildTableHTML(tradeData.sales, 'sale', getCurrencyDisplay(token.currency))}</div>`;
        html += `<div class="line">Bought: ${formatAmount(tradeData.totalTokensBought)} (XRP Paid: ${formatAmount(tradeData.totalXrpSpent)}) <span class="expandable" onclick="toggleSection('purchases_${token.issuer}')">[expand]</span></div>`;
        html += `<div id="purchases_${token.issuer}" class="hidden">${buildTableHTML(tradeData.purchases, 'purchase', getCurrencyDisplay(token.currency))}</div>`;
        html += `<div class="line">Transfers: ${formatAmount(tradeData.totalTokensTransferred)} (to ${tradeData.uniqueTransferAddresses} unique addresses) <span class="expandable" onclick="toggleSection('transfers_${token.issuer}')">[expand]</span></div>`;
        html += `<div id="transfers_${token.issuer}" class="hidden">${buildTableHTML(tradeData.transfers, 'transfer', getCurrencyDisplay(token.currency))}</div>`;
        return html;
      }
    },
    tier1: {
      async fetchData(issuer, currencyCode, activatorData, commonData) {
        const { activator, creationDate } = activatorData;
        updateLoadingMessage("Analyzing Tier 1 transfers");
        const tradeData = await fetchTradeData(activator, issuer, currencyCode, creationDate);
        let tier1TotalTransferred = 0, tier1TotalSold = 0, tier1TotalXrpReceived = 0, tier1TotalBought = 0, tier1TotalXrpSpent = 0;
        let tier1Wallets = {};
        tradeData.transfers.forEach(tx => {
          if (!tier1Wallets[tx.destination]) {
            tier1Wallets[tx.destination] = { tokensTransferred: 0, txs: [] };
          }
          tier1Wallets[tx.destination].tokensTransferred += tx.tokensTransferred;
          tier1Wallets[tx.destination].txs.push(tx);
        });
        let tier1Count = Object.keys(tier1Wallets).length;
        let tier1Details = {};
        for (let wallet of Object.keys(tier1Wallets)) {
          let tradeResult = await fetchTradeActivity(wallet, currencyCode, issuer, creationDate);
          tier1TotalTransferred += tier1Wallets[wallet].tokensTransferred;
          tier1TotalSold += tradeResult.totalTokensSold;
          tier1TotalXrpReceived += tradeResult.totalXrpReceived;
          tier1TotalBought += tradeResult.totalTokensBought;
          tier1TotalXrpSpent += tradeResult.totalXrpSpent;
          tier1Details[wallet] = {
            tokensTransferred: tier1Wallets[wallet].tokensTransferred,
            txs: tier1Wallets[wallet].txs,
            tradeResult
          };
        }
        return { 
          tier1TotalTransferred, 
          tier1TotalSold, 
          tier1TotalXrpReceived, 
          tier1TotalBought, 
          tier1TotalXrpSpent, 
          tier1Count, 
          tier1Details, 
          ...commonData 
        };
      },
      renderData(data) {
        const { tier1TotalTransferred, tier1TotalSold, tier1TotalXrpReceived, tier1TotalBought, tier1TotalXrpSpent, tier1Count, tier1Details, token } = data;
        let tier1DetailsHTML = "";
        for (let wallet of Object.keys(tier1Details)) {
          const { tokensTransferred, txs, tradeResult } = tier1Details[wallet];
          tier1DetailsHTML += `<div class="line">Address <a href="https://xrpscan.com/account/${wallet}" target="_blank">${wallet}</a> received ${formatAmount(tokensTransferred)} ${getCurrencyDisplay(token.currency)}, sold ${formatAmount(tradeResult.totalTokensSold)} for ${formatAmount(tradeResult.totalXrpReceived)} XRP, bought ${formatAmount(tradeResult.totalTokensBought)} for ${formatAmount(tradeResult.totalXrpSpent)} XRP. <span class="expandable" onclick="toggleSection('tier1_transfers_${wallet}_${token.issuer}')">[view transfers]</span> <span class="expandable" onclick="toggleSection('tier1_sales_${wallet}_${token.issuer}')">[view sales]</span> <span class="expandable" onclick="toggleSection('tier1_purchases_${wallet}_${token.issuer}')">[view purchases]</span></div>`;
          tier1DetailsHTML += `<div id="tier1_transfers_${wallet}_${token.issuer}" class="hidden">${buildTableHTML(txs, 'transfer', getCurrencyDisplay(token.currency))}</div>`;
          tier1DetailsHTML += `<div id="tier1_sales_${wallet}_${token.issuer}" class="hidden">${buildTableHTML(tradeResult.saleTxs, 'sale', getCurrencyDisplay(token.currency))}</div>`;
          tier1DetailsHTML += `<div id="tier1_purchases_${wallet}_${token.issuer}" class="hidden">${buildTableHTML(tradeResult.purchaseTxs, 'purchase', getCurrencyDisplay(token.currency))}</div>`;
        }
        let tier1SummaryHTML = `<div class="expanded">
            <div class="line">DEV transferred a total of ${formatAmount(tier1TotalTransferred)} ${getCurrencyDisplay(token.currency)} to ${tier1Count} addresses, which sold ${formatAmount(tier1TotalSold)} for ${formatAmount(tier1TotalXrpReceived)} XRP and bought ${formatAmount(tier1TotalBought)} for ${formatAmount(tier1TotalXrpSpent)} XRP.</div>
            <div class="line"><span class="expandable" onclick="toggleSection('tier1Details_${token.issuer}')">[view Tier 1 details]</span></div>
            <div id="tier1Details_${token.issuer}" class="hidden">${tier1DetailsHTML}</div>
          </div>`;

        let html = `<div class="header">Token Outflow - Tier 1</div>`;
        html += `<div class="separator"></div>`;
        html += tier1SummaryHTML;
        return html;
      }
    },
    tier2: {
      async fetchData(issuer, currencyCode, activatorData, commonData) {
        const { activator, creationDate } = activatorData;
        updateLoadingMessage("Analyzing Tier 2 transfers");
        const tradeData = await fetchTradeData(activator, issuer, currencyCode, creationDate);
        let tier1Wallets = {};
        tradeData.transfers.forEach(tx => {
          if (!tier1Wallets[tx.destination]) {
            tier1Wallets[tx.destination] = { tokensTransferred: 0, txs: [] };
          }
          tier1Wallets[tx.destination].tokensTransferred += tx.tokensTransferred;
          tier1Wallets[tx.destination].txs.push(tx);
        });

        let tier2Data = {};
        for (let wallet of Object.keys(tier1Wallets)) {
          let tier1Tx = await fetchWalletTransactions(wallet, currencyCode, issuer, creationDate);
          tier1Tx.transfers.forEach(tx => {
            if (!tier2Data[tx.destination]) {
              tier2Data[tx.destination] = { tokensTransferred: 0, txs: [] };
            }
            tier2Data[tx.destination].tokensTransferred += tx.tokensTransferred;
            tier2Data[tx.destination].txs.push(tx);
          });
        }
        let tier2Wallets = Object.keys(tier2Data);
        let tier2TotalTransferred = 0, tier2TotalSold = 0, tier2TotalXrpReceived = 0, tier2TotalBought = 0, tier2TotalXrpSpent = 0;
        let tier2Details = {};
        for (let wallet of tier2Wallets) {
          let tradeResult = await fetchTradeActivity(wallet, currencyCode, issuer, creationDate);
          tier2TotalTransferred += tier2Data[wallet].tokensTransferred;
          tier2TotalSold += tradeResult.totalTokensSold;
          tier2TotalXrpReceived += tradeResult.totalXrpReceived;
          tier2TotalBought += tradeResult.totalTokensBought;
          tier2TotalXrpSpent += tradeResult.totalXrpSpent;
          tier2Details[wallet] = {
            tokensTransferred: tier2Data[wallet].tokensTransferred,
            txs: tier2Data[wallet].txs,
            tradeResult
          };
        }
        return { 
          tier2TotalTransferred, 
          tier2TotalSold, 
          tier2TotalXrpReceived, 
          tier2TotalBought, 
          tier2TotalXrpSpent, 
          tier2Wallets, 
          tier2Details, 
          ...commonData 
        };
      },
      renderData(data) {
        const { tier2TotalTransferred, tier2TotalSold, tier2TotalXrpReceived, tier2TotalBought, tier2TotalXrpSpent, tier2Wallets, tier2Details, token } = data;
        let tier2DetailsHTML = "";
        for (let wallet of tier2Wallets) {
          const { tokensTransferred, txs, tradeResult } = tier2Details[wallet];
          tier2DetailsHTML += `<div class="line">Address <a href="https://xrpscan.com/account/${wallet}" target="_blank">${wallet}</a> received ${formatAmount(tokensTransferred)} ${getCurrencyDisplay(token.currency)}, sold ${formatAmount(tradeResult.totalTokensSold)} for ${formatAmount(tradeResult.totalXrpReceived)} XRP, bought ${formatAmount(tradeResult.totalTokensBought)} for ${formatAmount(tradeResult.totalXrpSpent)} XRP. <span class="expandable" onclick="toggleSection('tier2_transfers_${wallet}_${token.issuer}')">[view transfers]</span> <span class="expandable" onclick="toggleSection('tier2_sales_${wallet}_${token.issuer}')">[view sales]</span> <span class="expandable" onclick="toggleSection('tier2_purchases_${wallet}_${token.issuer}')">[view purchases]</span></div>`;
          tier2DetailsHTML += `<div id="tier2_transfers_${wallet}_${token.issuer}" class="hidden">${buildTableHTML(txs, 'transfer', getCurrencyDisplay(token.currency))}</div>`;
          tier2DetailsHTML += `<div id="tier2_sales_${wallet}_${token.issuer}" class="hidden">${buildTableHTML(tradeResult.saleTxs, 'sale', getCurrencyDisplay(token.currency))}</div>`;
          tier2DetailsHTML += `<div id="tier2_purchases_${wallet}_${token.issuer}" class="hidden">${buildTableHTML(tradeResult.purchaseTxs, 'purchase', getCurrencyDisplay(token.currency))}</div>`;
        }
        let tier2SummaryHTML = `<div class="expanded">
            <div class="line">Tier 1 addresses transferred a total of ${formatAmount(tier2TotalTransferred)} ${getCurrencyDisplay(token.currency)} to ${tier2Wallets.length} addresses, which sold ${formatAmount(tier2TotalSold)} for ${formatAmount(tier2TotalXrpReceived)} XRP and bought ${formatAmount(tier2TotalBought)} for ${formatAmount(tier2TotalXrpSpent)} XRP.</div>
            <div class="line"><span class="expandable" onclick="toggleSection('tier2Details_${token.issuer}')">[view Tier 2 details]</span></div>
            <div id="tier2Details_${token.issuer}" class="hidden">${tier2DetailsHTML}</div>
          </div>`;

        let html = `<div class="header">Token Outflow - Tier 2</div>`;
        html += `<div class="separator"></div>`;
        html += tier2SummaryHTML;
        return html;
      }
    },
    wallet: {
  async fetchData(wallet) {
    updateLoadingMessage("Fetching wallet transaction history");
    const client = await connectClient();
    try {
      // Fetch all transactions for the wallet
      let transactions = [];
      let marker;
      let txCount = 0;
      const maxTxCount = 20000;
      do {
        const txResponse = await fetchWithRetry(client, {
          command: "account_tx",
          account: wallet,
          ledger_index_min: -1,
          ledger_index_max: -1,
          forward: true,
          limit: 200,
          ...(marker ? { marker } : {})
        });
        if (!txResponse.result || !txResponse.result.transactions) {
          console.error(`No transactions returned for ${wallet}, response:`, txResponse);
          throw new Error("Failed to retrieve transactions. Please try again.");
        }
        const txs = txResponse.result.transactions || [];
        transactions = transactions.concat(txs);
        txCount += txs.length;
        console.log(`Fetched ${txs.length} transactions for ${wallet}, total: ${txCount}`);
        marker = txResponse.result.marker;
        if (!marker || !txs.length || txCount >= maxTxCount) break;
      } while (marker);

      console.log(`Total transactions fetched for ${wallet}: ${transactions.length}`);

      // Analyze transactions to identify tokens purchased or sold
      const tokenDetails = {};
      const tokenTimestamps = {}; // Track latest transaction date for each token
      const seenTokens = new Set();
      for (const txEntry of transactions) {
        const tx = txEntry.tx;
        const meta = txEntry.meta;
        if (
          (tx.TransactionType === 'Payment' ||
           tx.TransactionType === 'OfferCreate' ||
           tx.TransactionType === 'CheckCash' ||
           tx.TransactionType === 'AMMBid' ||
           tx.TransactionType === 'AMMVote') &&
          meta?.TransactionResult === 'tesSUCCESS'
        ) {
          const balanceChanges = xrpl.getBalanceChanges(meta);
          const walletChanges = balanceChanges.find(change => change.account === wallet);
          if (walletChanges) {
            for (const balance of walletChanges.balances) {
              if (balance.currency !== 'XRP' && balance.issuer) {
                const tokenKey = `${balance.issuer}_${balance.currency}`;
                if (!seenTokens.has(tokenKey)) {
                  seenTokens.add(tokenKey);
                  tokenDetails[tokenKey] = {
                    currency: balance.currency,
                    issuer: balance.issuer,
                    currentBalance: 0,
                    tokensBought: 0,
                    xrpSpent: 0,
                    tokensSold: 0,
                    xrpReceived: 0,
                    buyTxs: [],
                    sellTxs: [],
                    profit: 0
                  };
                }
                const tokenValue = parseFloat(balance.value);
                const xrpChange = walletChanges.balances.find(b => b.currency === 'XRP');
                if (xrpChange) {
                  const xrpValue = parseFloat(xrpChange.value);
                  if (tokenValue > 0 && xrpValue < 0) {
                    // Purchase
                    const tokensBought = tokenValue;
                    const xrpSpent = Math.abs(xrpValue);
                    tokenDetails[tokenKey].tokensBought += tokensBought;
                    tokenDetails[tokenKey].xrpSpent += xrpSpent;
                    tokenDetails[tokenKey].buyTxs.push({
                      txHash: tx.hash,
                      tokensBought,
                      xrpSpent
                    });
                    console.log(`Purchase detected for ${balance.currency}: ${tx.hash}, Tokens bought: ${tokensBought}, XRP spent: ${xrpSpent}`);
                    // Update latest transaction timestamp
                    if (!tokenTimestamps[tokenKey] || tx.date > tokenTimestamps[tokenKey]) {
                      tokenTimestamps[tokenKey] = tx.date;
                    }
                  } else if (tokenValue < 0 && xrpValue > 0) {
                    // Sale
                    const tokensSold = Math.abs(tokenValue);
                    const xrpReceived = xrpValue;
                    tokenDetails[tokenKey].tokensSold += tokensSold;
                    tokenDetails[tokenKey].xrpReceived += xrpReceived;
                    tokenDetails[tokenKey].sellTxs.push({
                      txHash: tx.hash,
                      tokensSold,
                      xrpReceived
                    });
                    console.log(`Sale detected for ${balance.currency}: ${tx.hash}, Tokens sold: ${tokensSold}, XRP received: ${xrpReceived}`);
                    // Update latest transaction timestamp
                    if (!tokenTimestamps[tokenKey] || tx.date > tokenTimestamps[tokenKey]) {
                      tokenTimestamps[tokenKey] = tx.date;
                    }
                  }
                }
              }
            }
          }
        }
      }

      // Fetch current trust lines to update current balances for purchased/sold tokens
      let trustLines = [];
      marker = undefined;
      txCount = 0;
      do {
        const response = await fetchWithRetry(client, {
          command: "account_lines",
          account: wallet,
          ledger_index: "validated",
          limit: 2000,
          ...(marker ? { marker } : {})
        });
        if (!response.result || !response.result.lines) {
          console.error(`No trust lines returned for ${wallet}, response:`, response);
          throw new Error("Failed to retrieve trust lines. Please try again.");
        }
        const lines = response.result.lines || [];
        trustLines = trustLines.concat(lines);
        marker = response.result.marker;
        txCount += lines.length;
        console.log(`Fetched ${lines.length} trust lines for ${wallet}, total: ${txCount}`);
        if (!marker || !lines.length || txCount >= maxTxCount) break;
      } while (marker);

      console.log(`Total trust lines fetched for ${wallet}: ${trustLines.length}`);

      // Update current balances only for tokens with purchase/sale activity
      for (const line of trustLines) {
        const key = `${line.account}_${line.currency}`;
        if (tokenDetails[key]) {
          tokenDetails[key].currentBalance = parseFloat(line.balance);
        }
      }

      // Filter tokens to only those with purchases or sales and sort by latest transaction
      const tokens = Array.from(seenTokens)
        .filter(key => tokenDetails[key].tokensBought > 0 || tokenDetails[key].tokensSold > 0)
        .map(key => {
          const [issuer, currency] = key.split('_');
          return {
            issuer,
            currency,
            currentBalance: tokenDetails[key].currentBalance,
            latestTxDate: tokenTimestamps[key] || 0
          };
        })
        .sort((a, b) => b.latestTxDate - a.latestTxDate);

      // Calculate profit/loss for each token
      for (const key of Object.keys(tokenDetails)) {
        tokenDetails[key].profit = tokenDetails[key].xrpReceived - tokenDetails[key].xrpSpent;
      }

      console.log(`Total tokens with purchase/sale activity for ${wallet}: ${tokens.length}`, tokens);

      return { tokens, tokenDetails };
    } catch (error) {
      console.error('Error in wallet fetchData:', error);
      throw error;
    } finally {
      await client.disconnect();
    }
  },
  renderData(data) {
  const { tokens, tokenDetails } = data;
  let html = `<div class="header">Trade History</div>`;
  html += `
    <div class="line">
      <label style="cursor: pointer; margin-right: 20px;">
        <input type="checkbox" id="xrp-values-toggle" onchange="toggleXrpValuesOnly()" checked>
        XRP Values Only
      </label>
      <label style="cursor: pointer;">
        <input type="checkbox" id="zero-balance-toggle" onchange="toggleZeroBalanceOnly()">
        Zero Balance Only
      </label>
    </div>
  `;
  if (tokens.length === 0) {
    html += `<div class="line">No token purchase or sale activity found for this wallet.</div>`;
  } else {
    html += `<table>`;
    html += `<tr><th>Token</th><th>Balance</th><th>Bought</th><th>Spent</th><th>Sold</th><th>Received</th><th>P/L</th></tr>`;
    tokens.forEach((token, index) => {
      const key = `${token.issuer}_${token.currency}`;
      const details = tokenDetails[key] || {
        currentBalance: token.currentBalance,
        tokensBought: 0,
        xrpSpent: 0,
        tokensSold: 0,
        xrpReceived: 0,
        profit: 0,
        buyTxs: [],
        sellTxs: []
      };
      let p_l_display, p_l_color;
      if (details.tokensSold === 0 && details.xrpReceived === 0) {
        p_l_display = `0 XRP`;
        p_l_color = 'white';
      } else {
        const isProfit = details.profit >= 0;
        const symbol = isProfit ? '+' : '';
        p_l_display = `${symbol}${formatAmount(Math.abs(details.profit))} XRP`;
        p_l_color = isProfit ? '#66bb6a' : '#ef5350';
      }
      const rowParityClass = index % 2 === 0 ? 'token-row-even' : 'token-row-odd';
      html += `<tr class="token-row ${rowParityClass}" onclick="toggleSection('token_details_${key}')" style="cursor: pointer;">`;
      html += `<td style="overflow: hidden; text-overflow: ellipsis;" title="${getCurrencyDisplay(token.currency)}"><a href="https://xrpscan.com/account/${token.issuer}" target="_blank">${getCurrencyDisplay(token.currency)}</a></td>`;
      html += `<td>${formatAmount(details.currentBalance)}</td>`;
      html += `<td>${formatAmount(details.tokensBought)}</td>`;
      html += `<td>${formatAmount(details.xrpSpent)} XRP</td>`;
      html += `<td>${formatAmount(details.tokensSold)}</td>`;
      html += `<td>${formatAmount(details.xrpReceived)} XRP</td>`;
      html += `<td style="color: ${p_l_color}">${p_l_display}</td>`;
      html += `</tr>`;
      html += `<tr id="token_details_${key}" class="details-row hidden"><td colspan="7">`;
      html += `
        <div class="pnl-card" id="pnl-card-${key}">
          <div class="pnl-card-header">
            <img src="https://i.ibb.co/svZT9rZQ/Magic-Eraser-250603-140451.png" alt="Inspection Ninja Icon" class="pnl-card-icon">
            <div class="pnl-card-title">Inspection Ninja <span class="pnl">PnL</span></div>
          </div>
          <div class="pnl-card-token">${getCurrencyDisplay(token.currency)}</div>
          <div class="pnl-card-profit ${details.profit >= 0 ? 'pnl-profit-positive' : 'pnl-profit-negative'}">
            ${details.profit >= 0 ? '+' : '-'}${Math.abs((details.xrpSpent > 0 ? (details.profit / details.xrpSpent) * 100 : (details.profit > 0 ? Infinity : 0))).toFixed(2)}%
          </div>
          <div class="pnl-card-content">
            <div class="pnl-card-row">
              <div class="pnl-card-column">
                <span class="pnl-card-label">Bought</span>
                <span class="pnl-card-value">${formatAmount(details.xrpSpent)} XRP</span>
              </div>
              <div class="pnl-card-column">
                <span class="pnl-card-label">${details.profit >= 0 ? 'Profit' : 'Loss'}</span>
                <span class="pnl-card-value ${details.profit >= 0 ? 'pnl-profit-positive' : 'pnl-profit-negative'}">${formatAmount(Math.abs(details.profit))} XRP</span>
              </div>
            </div>
            <div class="pnl-transactions">
              ${details.buyTxs.length > 0 ? `
                <div class="line">Purchases: <span class="expandable" onclick="event.stopPropagation(); toggleSection('buy_txs_${key}')">[view]</span></div>
                <div id="buy_txs_${key}" class="hidden">${buildTableHTML(details.buyTxs, 'purchase', getCurrencyDisplay(token.currency))}</div>
              ` : `<div class="line">Purchases: None</div>`}
              ${details.sellTxs.length > 0 ? `
                <div class="line">Sales: <span class="expandable" onclick="event.stopPropagation(); toggleSection('sell_txs_${key}')">[view]</span></div>
                <div id="sell_txs_${key}" class="hidden">${buildTableHTML(details.sellTxs, 'sale', getCurrencyDisplay(token.currency))}</div>
              ` : `<div class="line">Sales: None</div>`}
            </div>
          </div>
          <button class="download-btn" onclick="event.stopPropagation(); downloadPnLCard('pnl-card-${key}', '${getCurrencyDisplay(token.currency).replace(/'/g, "\\'")}')">
            <img src="https://i.ibb.co/3m0LddNz/IMG-7147.png">
            Download PnL Card
          </button>
        </div>`;
      html += `</td></tr>`;
    });
    html += `</table>`;
  }
  // Call toggleXrpValuesOnly to apply the XRP Values Only styling
  setTimeout(() => {
    toggleXrpValuesOnly();
  }, 0);
  return html;
}
},
      snipers: {
      async fetchData(issuer, currencyCode) {
        enrichedPayments = await getPaymentTransactions(issuer, currencyCode);
        enrichedPayments.currencyCode = currencyCode;
        enrichedPayments.issuer = issuer;
        return { payments: enrichedPayments, currencyCode, issuer };
      },
            renderData(data) {
  const { payments, currencyCode, issuer } = data;
  let html = `<div class="header">Snipers</div>`;
  html += `<div class="line">Currency: ${getCurrencyDisplay(currencyCode)}</div>`;
  html += `<div class="line">Issuer: <a href="https://xrpscan.com/account/${issuer}" target="_blank">${issuer}</a></div>`;

  if (payments.length === 0) {
    html += `<div class="line">No sniper transactions found.</div>`;
  } else {
    html += `<table>`;
    html += `<tr><th>#</th><th>Transaction</th><th>Purchaser</th><th>Spent</th><th>Tokens Received</th></tr>`;
    payments.forEach((payment, index) => {
      const txHash = payment.txHash;
      html += `<tr onclick="togglePurchaserDetails('${txHash}', '${payment.purchaser}', '${issuer}', '${currencyCode}')">`;
      html += `<td>${index + 1}</td>`;
      html += `<td><a href="https://xrpscan.com/tx/${txHash}" target="_blank">view</a></td>`;
      html += `<td><a href="https://xrpscan.com/account/${payment.purchaser}" target="_blank">${payment.purchaser}</a></td>`;
      html += `<td><span class="xrp-cell"><span class="icon"><img src="https://i.ibb.co/0j9qD7J3/Magic-Eraser-250603-113358.png" alt="XRP" class="xrp-icon"></span><span class="xrp-value">${formatAmount(payment.xrpSpent)}</span></span></td>`;
      html += `<td>${formatAmount(payment.amount)} ${getCurrencyDisplay(currencyCode)}</td>`;
      html += `</tr>`;
      html += `<tr id="details_${txHash}" class="details-row hidden"><td colspan="5"><div id="details_content_${txHash}"></div></td></tr>`;
    });
    html += `</table>`;
  }
  return html;
}
      }
    };

  /* ---------- Main Fetch and Render Logic ---------- */
  async function fetchTokenInfo(address, scope) {
  console.log(`Fetching info for address: ${address}, scope: ${scope}`);
  if (!validateIssuerAddress(address)) {
    displayError("Invalid address format");
    return;
  }

  updateLoadingMessage("Conducting deep dive...");
  const output = document.getElementById("output");
  try {
    if (scope === 'wallet') {
      const data = await scopeModules.wallet.fetchData(address);
      const html = scopeModules.wallet.renderData(data);
      output.innerHTML = html;
      addNewPrompt();
    } else if (scope === 'snipers') {
      const currencyCode = await getCurrencyCode(address);
      const data = await scopeModules.snipers.fetchData(address, currencyCode);
      const html = scopeModules.snipers.renderData(data);
      output.innerHTML = html;
      addNewPrompt();
    } else {
      const currencyCode = await getCurrencyCode(address);
      const activatorData = await getActivatorAddress(address);
      const commonData = {
        activator: activatorData.activator,
        creationDate: activatorData.creationDate,
        isAntiSniper: activatorData.isAntiSniper
      };

      // Always include overview
      const overviewData = await scopeModules.overview.fetchData(address, currencyCode, activatorData, commonData);
      let html = scopeModules.overview.renderData({ ...overviewData, activator: activatorData.activator });

      // Include additional scopes as needed
      if (scope === 'dev' || scope === 'tier1' || scope === 'tier2') {
        const devData = await scopeModules.dev.fetchData(address, currencyCode, activatorData, { token: overviewData.token, metrics: overviewData.metrics });
        html += scopeModules.dev.renderData(devData);
      }

      if (scope === 'tier1' || scope === 'tier2') {
        const tier1Data = await scopeModules.tier1.fetchData(address, currencyCode, activatorData, { token: overviewData.token, metrics: overviewData.metrics });
        html += scopeModules.tier1.renderData(tier1Data);
      }

      if (scope === 'tier2') {
        const tier2Data = await scopeModules.tier2.fetchData(address, currencyCode, activatorData, { token: overviewData.token, metrics: overviewData.metrics });
        html += scopeModules.tier2.renderData(tier2Data);
      }

      output.innerHTML = html;
      addNewPrompt();
    }
  } catch (error) {
    console.error('Error in fetchTokenInfo:', error);
    displayError(error.message || "Failed to fetch data. Please try again.");
  }
}
  /* ---------- Update Input Placeholder ---------- */
async function fetchTokenInfo(address, scope) {
  console.log(`Fetching info for address: ${address}, scope: ${scope}`);
  if (scope !== 'wallet' && !validateIssuerAddress(address)) {
    displayError("Invalid issuer address format");
    return;
  }

  updateLoadingMessage("Conducting deep dive...");
  const output = document.getElementById("output");
  try {
    if (scope === 'wallet') {
      const data = await scopeModules.wallet.fetchData(address);
      const html = scopeModules.wallet.renderData(data);
      output.innerHTML = html;
      addNewPrompt();
    } else if (scope === 'snipers') {
      const currencyCode = await getCurrencyCode(address);
      const data = await scopeModules.snipers.fetchData(address, currencyCode);
      const html = scopeModules.snipers.renderData(data);
      output.innerHTML = html;
      addNewPrompt();
    } else {
      const currencyCode = await getCurrencyCode(address);
      const activatorData = await getActivatorAddress(address);
      const commonData = {
        activator: activatorData.activator,
        creationDate: activatorData.creationDate,
        isAntiSniper: activatorData.isAntiSniper
      };

      // Always include overview
      const overviewData = await scopeModules.overview.fetchData(address, currencyCode, activatorData, commonData);
      let html = scopeModules.overview.renderData({ ...overviewData, activator: activatorData.activator });

      // Include additional scopes as needed
      if (scope === 'dev' || scope === 'tier1' || scope === 'tier2') {
        const devData = await scopeModules.dev.fetchData(address, currencyCode, activatorData, { token: overviewData.token, metrics: overviewData.metrics });
        html += scopeModules.dev.renderData(devData);
      }

      if (scope === 'tier1' || scope === 'tier2') {
        const tier1Data = await scopeModules.tier1.fetchData(address, currencyCode, activatorData, { token: overviewData.token, metrics: overviewData.metrics });
        html += scopeModules.tier1.renderData(tier1Data);
      }

      if (scope === 'tier2') {
        const tier2Data = await scopeModules.tier2.fetchData(address, currencyCode, activatorData, { token: overviewData.token, metrics: overviewData.metrics });
        html += scopeModules.tier2.renderData(tier2Data);
      }

      output.innerHTML = html;
      addNewPrompt();
    }
  } catch (error) {
    console.error('Error in fetchTokenInfo:', error);
    displayError(error.message || "Failed to fetch data. Please try again.");
  }
}
/* ---------- Update Input Placeholder ---------- */
function updateInputPlaceholder(scope) {
  const cmdInput = document.getElementById("cmd-input");
  if (scope === 'wallet') {
    cmdInput.placeholder = "Enter Wallet Address";
  } else {
    cmdInput.placeholder = "Enter Issuer Address";
  }
}

  /* Custom Dropdown Logic */
  let selectedScope = 'overview';
  const toggle = document.getElementById('scope-toggle');
  const menu = document.getElementById('scope-menu');
  const options = document.querySelectorAll('.dropdown-option');

  toggle.addEventListener('click', (e) => {
    e.stopPropagation();
    console.log('Dropdown toggle clicked');
    menu.classList.toggle('show');
  });

  options.forEach(option => {
  option.addEventListener('click', (e) => {
    e.stopPropagation();
    console.log(`Dropdown option clicked: ${option.getAttribute('data-value')}`);
    selectedScope = option.getAttribute('data-value');
    const optionName = option.getAttribute('data-name');
    toggle.textContent = `Scope Level: ${optionName}`;
    menu.classList.remove('show');
    updateInputPlaceholder(selectedScope); // Add this line to update placeholder

    const cmdInput = document.getElementById("cmd-input");
    const inputIssuer = cmdInput.value.trim();

    if (inputIssuer) {
      if (selectedScope !== 'wallet' && !validateIssuerAddress(inputIssuer)) {
        displayError("Invalid issuer address format in input field.");
        return;
      }
      lastIssuer = inputIssuer;
      document.getElementById("output").innerHTML = "";
      fetchTokenInfo(lastIssuer, selectedScope);
    } else if (lastIssuer) {
      document.getElementById("output").innerHTML = "";
      fetchTokenInfo(lastIssuer, selectedScope);
    } else {
      displayError("Please enter an address first.");
    }
  });
});

  document.addEventListener('click', (e) => {
    if (!toggle.contains(e.target) && !menu.contains(e.target)) {
      console.log('Clicked outside dropdown, hiding menu');
      menu.classList.remove('show');
    }
  });

  document.getElementById("cmd-input").addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      console.log('Enter key pressed on cmd-input');
      const issuer = e.target.value.trim();
      if (!issuer) {
        displayError("Please enter an issuer address");
        return;
      }
      if (!validateIssuerAddress(issuer)) {
        displayError("Invalid issuer address format");
        return;
      }
      lastIssuer = issuer;
      document.getElementById("output").innerHTML = "";
      fetchTokenInfo(issuer, selectedScope);
      e.preventDefault();
    }
  });
</script>
</body>
</html>
